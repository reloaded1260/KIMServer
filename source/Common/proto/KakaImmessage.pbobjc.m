// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KakaIMMessage.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "KakaImmessage.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - KakaImmessageRoot

@implementation KakaImmessageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - KakaImmessageRoot_FileDescriptor

static GPBFileDescriptor *KakaImmessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"kakaIM.Node"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum UserGenderType

GPBEnumDescriptor *UserGenderType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Male\000Female\000Unkown\000";
    static const int32_t values[] = {
        UserGenderType_Male,
        UserGenderType_Female,
        UserGenderType_Unkown,
    };
    static const char *extraTextFormatInfo = "\003\000\004\000\001\006\000\002\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserGenderType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserGenderType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserGenderType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserGenderType_Male:
    case UserGenderType_Female:
    case UserGenderType_Unkown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageIDVersion

@implementation MessageIDVersion

@dynamic hasYear, year;
@dynamic hasMonth, month;
@dynamic hasDay, day;
@dynamic hasHour, hour;
@dynamic hasMiniute, miniute;
@dynamic hasSecond, second;

typedef struct MessageIDVersion__storage_ {
  uint32_t _has_storage_[1];
  int32_t year;
  int32_t month;
  int32_t day;
  int32_t hour;
  int32_t miniute;
  int32_t second;
} MessageIDVersion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "year",
        .dataTypeSpecific.className = NULL,
        .number = MessageIDVersion_FieldNumber_Year,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageIDVersion__storage_, year),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "month",
        .dataTypeSpecific.className = NULL,
        .number = MessageIDVersion_FieldNumber_Month,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageIDVersion__storage_, month),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "day",
        .dataTypeSpecific.className = NULL,
        .number = MessageIDVersion_FieldNumber_Day,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageIDVersion__storage_, day),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hour",
        .dataTypeSpecific.className = NULL,
        .number = MessageIDVersion_FieldNumber_Hour,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageIDVersion__storage_, hour),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "miniute",
        .dataTypeSpecific.className = NULL,
        .number = MessageIDVersion_FieldNumber_Miniute,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageIDVersion__storage_, miniute),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "second",
        .dataTypeSpecific.className = NULL,
        .number = MessageIDVersion_FieldNumber_Second,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MessageIDVersion__storage_, second),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageIDVersion class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageIDVersion__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestSessionIDMessage

@implementation RequestSessionIDMessage


typedef struct RequestSessionIDMessage__storage_ {
  uint32_t _has_storage_[1];
} RequestSessionIDMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestSessionIDMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RequestSessionIDMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseSessionIDMessage

@implementation ResponseSessionIDMessage

@dynamic hasSessionId, sessionId;

typedef struct ResponseSessionIDMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
} ResponseSessionIDMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ResponseSessionIDMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseSessionIDMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseSessionIDMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseSessionIDMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginMessage

@implementation LoginMessage

@dynamic hasSessionId, sessionId;
@dynamic hasUserAccount, userAccount;
@dynamic hasUserPassword, userPassword;

typedef struct LoginMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *userAccount;
  NSString *userPassword;
} LoginMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = LoginMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userAccount",
        .dataTypeSpecific.className = NULL,
        .number = LoginMessage_FieldNumber_UserAccount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginMessage__storage_, userAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userPassword",
        .dataTypeSpecific.className = NULL,
        .number = LoginMessage_FieldNumber_UserPassword,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LoginMessage__storage_, userPassword),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010A\000\002\013\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseLoginMessage

@implementation ResponseLoginMessage

@dynamic hasSessionId, sessionId;
@dynamic hasLoginState, loginState;
@dynamic hasFailureError, failureError;

typedef struct ResponseLoginMessage__storage_ {
  uint32_t _has_storage_[1];
  ResponseLoginMessage_LoginState loginState;
  ResponseLoginMessage_FailureError failureError;
  NSString *sessionId;
} ResponseLoginMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ResponseLoginMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ResponseLoginMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ResponseLoginMessage_LoginState_Success,
        .core.name = "loginState",
        .core.dataTypeSpecific.enumDescFunc = ResponseLoginMessage_LoginState_EnumDescriptor,
        .core.number = ResponseLoginMessage_FieldNumber_LoginState,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ResponseLoginMessage__storage_, loginState),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ResponseLoginMessage_FailureError_WrongAccountOrPassword,
        .core.name = "failureError",
        .core.dataTypeSpecific.enumDescFunc = ResponseLoginMessage_FailureError_EnumDescriptor,
        .core.number = ResponseLoginMessage_FieldNumber_FailureError,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ResponseLoginMessage__storage_, failureError),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLoginMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ResponseLoginMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010A\000\002\n\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ResponseLoginMessage_LoginState

GPBEnumDescriptor *ResponseLoginMessage_LoginState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Failure\000";
    static const int32_t values[] = {
        ResponseLoginMessage_LoginState_Success,
        ResponseLoginMessage_LoginState_Failure,
    };
    static const char *extraTextFormatInfo = "\002\000\007\000\001\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseLoginMessage_LoginState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseLoginMessage_LoginState_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseLoginMessage_LoginState_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseLoginMessage_LoginState_Success:
    case ResponseLoginMessage_LoginState_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResponseLoginMessage_FailureError

GPBEnumDescriptor *ResponseLoginMessage_FailureError_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "WrongAccountOrPassword\000InternalError\000";
    static const int32_t values[] = {
        ResponseLoginMessage_FailureError_WrongAccountOrPassword,
        ResponseLoginMessage_FailureError_InternalError,
    };
    static const char *extraTextFormatInfo = "\002\000\026\000\001\r\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseLoginMessage_FailureError)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseLoginMessage_FailureError_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseLoginMessage_FailureError_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseLoginMessage_FailureError_WrongAccountOrPassword:
    case ResponseLoginMessage_FailureError_InternalError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RegisterMessage

@implementation RegisterMessage

@dynamic hasSessionId, sessionId;
@dynamic hasUserAccount, userAccount;
@dynamic hasUserPassword, userPassword;
@dynamic hasUserNickName, userNickName;
@dynamic hasSex, sex;

typedef struct RegisterMessage__storage_ {
  uint32_t _has_storage_[1];
  RegisterMessage_UserSex sex;
  NSString *sessionId;
  NSString *userAccount;
  NSString *userPassword;
  NSString *userNickName;
} RegisterMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = RegisterMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(RegisterMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userAccount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = RegisterMessage_FieldNumber_UserAccount,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(RegisterMessage__storage_, userAccount),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userPassword",
        .core.dataTypeSpecific.className = NULL,
        .core.number = RegisterMessage_FieldNumber_UserPassword,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(RegisterMessage__storage_, userPassword),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userNickName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = RegisterMessage_FieldNumber_UserNickName,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(RegisterMessage__storage_, userNickName),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = RegisterMessage_UserSex_Unkown,
        .core.name = "sex",
        .core.dataTypeSpecific.enumDescFunc = RegisterMessage_UserSex_EnumDescriptor,
        .core.number = RegisterMessage_FieldNumber_Sex,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(RegisterMessage__storage_, sex),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(RegisterMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\010A\000\002\013\000\003\014\000\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RegisterMessage_UserSex

GPBEnumDescriptor *RegisterMessage_UserSex_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Male\000Female\000Unkown\000";
    static const int32_t values[] = {
        RegisterMessage_UserSex_Male,
        RegisterMessage_UserSex_Female,
        RegisterMessage_UserSex_Unkown,
    };
    static const char *extraTextFormatInfo = "\003\000$\000\001&\000\002\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RegisterMessage_UserSex)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RegisterMessage_UserSex_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RegisterMessage_UserSex_IsValidValue(int32_t value__) {
  switch (value__) {
    case RegisterMessage_UserSex_Male:
    case RegisterMessage_UserSex_Female:
    case RegisterMessage_UserSex_Unkown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ResponseRegisterMessage

@implementation ResponseRegisterMessage

@dynamic hasSessionId, sessionId;
@dynamic hasRegisterState, registerState;
@dynamic hasFailureError, failureError;

typedef struct ResponseRegisterMessage__storage_ {
  uint32_t _has_storage_[1];
  ResponseRegisterMessage_RegisterState registerState;
  ResponseRegisterMessage_FailureError failureError;
  NSString *sessionId;
} ResponseRegisterMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ResponseRegisterMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ResponseRegisterMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ResponseRegisterMessage_RegisterState_Success,
        .core.name = "registerState",
        .core.dataTypeSpecific.enumDescFunc = ResponseRegisterMessage_RegisterState_EnumDescriptor,
        .core.number = ResponseRegisterMessage_FieldNumber_RegisterState,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ResponseRegisterMessage__storage_, registerState),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = ResponseRegisterMessage_FailureError_AccountAlreadyExists,
        .core.name = "failureError",
        .core.dataTypeSpecific.enumDescFunc = ResponseRegisterMessage_FailureError_EnumDescriptor,
        .core.number = ResponseRegisterMessage_FieldNumber_FailureError,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(ResponseRegisterMessage__storage_, failureError),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseRegisterMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ResponseRegisterMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010A\000\002\r\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ResponseRegisterMessage_RegisterState

GPBEnumDescriptor *ResponseRegisterMessage_RegisterState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Failure\000";
    static const int32_t values[] = {
        ResponseRegisterMessage_RegisterState_Success,
        ResponseRegisterMessage_RegisterState_Failure,
    };
    static const char *extraTextFormatInfo = "\002\000\007\000\001\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseRegisterMessage_RegisterState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseRegisterMessage_RegisterState_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseRegisterMessage_RegisterState_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseRegisterMessage_RegisterState_Success:
    case ResponseRegisterMessage_RegisterState_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResponseRegisterMessage_FailureError

GPBEnumDescriptor *ResponseRegisterMessage_FailureError_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "AccountAlreadyExists\000InternalError\000";
    static const int32_t values[] = {
        ResponseRegisterMessage_FailureError_AccountAlreadyExists,
        ResponseRegisterMessage_FailureError_InternalError,
    };
    static const char *extraTextFormatInfo = "\002\000\024\000\001\r\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseRegisterMessage_FailureError)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseRegisterMessage_FailureError_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseRegisterMessage_FailureError_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseRegisterMessage_FailureError_AccountAlreadyExists:
    case ResponseRegisterMessage_FailureError_InternalError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - HeartBeatMessage

@implementation HeartBeatMessage

@dynamic hasSessionId, sessionId;
@dynamic hasTimestamp, timestamp;

typedef struct HeartBeatMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *timestamp;
} HeartBeatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = HeartBeatMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HeartBeatMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = HeartBeatMessage_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HeartBeatMessage__storage_, timestamp),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HeartBeatMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HeartBeatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseHeartBeatMessage

@implementation ResponseHeartBeatMessage

@dynamic hasSessionId, sessionId;
@dynamic hasTimestamp, timestamp;

typedef struct ResponseHeartBeatMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *timestamp;
} ResponseHeartBeatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ResponseHeartBeatMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseHeartBeatMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ResponseHeartBeatMessage_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseHeartBeatMessage__storage_, timestamp),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseHeartBeatMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseHeartBeatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogoutMessage

@implementation LogoutMessage

@dynamic hasSessionId, sessionId;
@dynamic hasOfflineMaileState, offlineMaileState;

typedef struct LogoutMessage__storage_ {
  uint32_t _has_storage_[1];
  LogoutMessage_OfflineMailState offlineMaileState;
  NSString *sessionId;
} LogoutMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = LogoutMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(LogoutMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = LogoutMessage_OfflineMailState_Open,
        .core.name = "offlineMaileState",
        .core.dataTypeSpecific.enumDescFunc = LogoutMessage_OfflineMailState_EnumDescriptor,
        .core.number = LogoutMessage_FieldNumber_OfflineMaileState,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(LogoutMessage__storage_, offlineMaileState),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogoutMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(LogoutMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010A\000\002\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum LogoutMessage_OfflineMailState

GPBEnumDescriptor *LogoutMessage_OfflineMailState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Open\000Close\000";
    static const int32_t values[] = {
        LogoutMessage_OfflineMailState_Open,
        LogoutMessage_OfflineMailState_Close,
    };
    static const char *extraTextFormatInfo = "\002\000\004\000\001\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LogoutMessage_OfflineMailState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LogoutMessage_OfflineMailState_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LogoutMessage_OfflineMailState_IsValidValue(int32_t value__) {
  switch (value__) {
    case LogoutMessage_OfflineMailState_Open:
    case LogoutMessage_OfflineMailState_Close:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ResponseLogoutMessage

@implementation ResponseLogoutMessage

@dynamic hasSessionId, sessionId;
@dynamic hasOfflineMaileState, offlineMaileState;

typedef struct ResponseLogoutMessage__storage_ {
  uint32_t _has_storage_[1];
  ResponseLogoutMessage_OfflineMailState offlineMaileState;
  NSString *sessionId;
} ResponseLogoutMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = ResponseLogoutMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ResponseLogoutMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = ResponseLogoutMessage_OfflineMailState_Open,
        .core.name = "offlineMaileState",
        .core.dataTypeSpecific.enumDescFunc = ResponseLogoutMessage_OfflineMailState_EnumDescriptor,
        .core.number = ResponseLogoutMessage_FieldNumber_OfflineMaileState,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ResponseLogoutMessage__storage_, offlineMaileState),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseLogoutMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ResponseLogoutMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010A\000\002\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ResponseLogoutMessage_OfflineMailState

GPBEnumDescriptor *ResponseLogoutMessage_OfflineMailState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Open\000Close\000";
    static const int32_t values[] = {
        ResponseLogoutMessage_OfflineMailState_Open,
        ResponseLogoutMessage_OfflineMailState_Close,
    };
    static const char *extraTextFormatInfo = "\002\000\004\000\001\005\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseLogoutMessage_OfflineMailState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseLogoutMessage_OfflineMailState_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseLogoutMessage_OfflineMailState_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseLogoutMessage_OfflineMailState_Open:
    case ResponseLogoutMessage_OfflineMailState_Close:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BuildingRelationshipRequestMessage

@implementation BuildingRelationshipRequestMessage

@dynamic hasSessionId, sessionId;
@dynamic hasSponsorAccount, sponsorAccount;
@dynamic hasTargetAccount, targetAccount;
@dynamic hasMessageId, messageId;
@dynamic hasMessageIdversion, messageIdversion;

typedef struct BuildingRelationshipRequestMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *sponsorAccount;
  NSString *targetAccount;
  MessageIDVersion *messageIdversion;
  uint64_t messageId;
} BuildingRelationshipRequestMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = BuildingRelationshipRequestMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuildingRelationshipRequestMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sponsorAccount",
        .dataTypeSpecific.className = NULL,
        .number = BuildingRelationshipRequestMessage_FieldNumber_SponsorAccount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuildingRelationshipRequestMessage__storage_, sponsorAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetAccount",
        .dataTypeSpecific.className = NULL,
        .number = BuildingRelationshipRequestMessage_FieldNumber_TargetAccount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuildingRelationshipRequestMessage__storage_, targetAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = BuildingRelationshipRequestMessage_FieldNumber_MessageId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BuildingRelationshipRequestMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "messageIdversion",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageIDVersion),
        .number = BuildingRelationshipRequestMessage_FieldNumber_MessageIdversion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BuildingRelationshipRequestMessage__storage_, messageIdversion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuildingRelationshipRequestMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuildingRelationshipRequestMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\010A\000\002\016\000\003\r\000\004\010A\000\005\010b\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuildingRelationshipAnswerMessage

@implementation BuildingRelationshipAnswerMessage

@dynamic hasSessionId, sessionId;
@dynamic hasTargetAccount, targetAccount;
@dynamic hasSponsorAccount, sponsorAccount;
@dynamic hasAnswer, answer;
@dynamic hasMessageId, messageId;
@dynamic hasMessageIdversion, messageIdversion;

typedef struct BuildingRelationshipAnswerMessage__storage_ {
  uint32_t _has_storage_[1];
  BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer answer;
  NSString *sessionId;
  NSString *targetAccount;
  NSString *sponsorAccount;
  MessageIDVersion *messageIdversion;
  uint64_t messageId;
} BuildingRelationshipAnswerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = BuildingRelationshipAnswerMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(BuildingRelationshipAnswerMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "targetAccount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = BuildingRelationshipAnswerMessage_FieldNumber_TargetAccount,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(BuildingRelationshipAnswerMessage__storage_, targetAccount),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "sponsorAccount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = BuildingRelationshipAnswerMessage_FieldNumber_SponsorAccount,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(BuildingRelationshipAnswerMessage__storage_, sponsorAccount),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_BuildingRelationshipAnswerAccept,
        .core.name = "answer",
        .core.dataTypeSpecific.enumDescFunc = BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_EnumDescriptor,
        .core.number = BuildingRelationshipAnswerMessage_FieldNumber_Answer,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(BuildingRelationshipAnswerMessage__storage_, answer),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "messageId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = BuildingRelationshipAnswerMessage_FieldNumber_MessageId,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(BuildingRelationshipAnswerMessage__storage_, messageId),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "messageIdversion",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MessageIDVersion),
        .core.number = BuildingRelationshipAnswerMessage_FieldNumber_MessageIdversion,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(BuildingRelationshipAnswerMessage__storage_, messageIdversion),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuildingRelationshipAnswerMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(BuildingRelationshipAnswerMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\010A\000\002\r\000\003\016\000\005\010A\000\006\010b\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer

GPBEnumDescriptor *BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "BuildingRelationshipAnswerAccept\000Buildin"
        "gRelationshipAnswerReject\000";
    static const int32_t values[] = {
        BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_BuildingRelationshipAnswerAccept,
        BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_BuildingRelationshipAnswerReject,
    };
    static const char *extraTextFormatInfo = "\002\000\032\206\000\001\032\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_IsValidValue(int32_t value__) {
  switch (value__) {
    case BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_BuildingRelationshipAnswerAccept:
    case BuildingRelationshipAnswerMessage_BuildingRelationshipAnswer_BuildingRelationshipAnswerReject:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DestroyingRelationshipRequestMessage

@implementation DestroyingRelationshipRequestMessage

@dynamic hasSessionId, sessionId;
@dynamic hasSponsorAccount, sponsorAccount;
@dynamic hasTargetAccount, targetAccount;

typedef struct DestroyingRelationshipRequestMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *sponsorAccount;
  NSString *targetAccount;
} DestroyingRelationshipRequestMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = DestroyingRelationshipRequestMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DestroyingRelationshipRequestMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sponsorAccount",
        .dataTypeSpecific.className = NULL,
        .number = DestroyingRelationshipRequestMessage_FieldNumber_SponsorAccount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DestroyingRelationshipRequestMessage__storage_, sponsorAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "targetAccount",
        .dataTypeSpecific.className = NULL,
        .number = DestroyingRelationshipRequestMessage_FieldNumber_TargetAccount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DestroyingRelationshipRequestMessage__storage_, targetAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DestroyingRelationshipRequestMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DestroyingRelationshipRequestMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010A\000\002\016\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DestoryingRelationshipResponseMessage

@implementation DestoryingRelationshipResponseMessage

@dynamic hasSessionId, sessionId;
@dynamic hasSponsorAccount, sponsorAccount;
@dynamic hasTargetAccount, targetAccount;
@dynamic hasResponse, response;

typedef struct DestoryingRelationshipResponseMessage__storage_ {
  uint32_t _has_storage_[1];
  DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse response;
  NSString *sessionId;
  NSString *sponsorAccount;
  NSString *targetAccount;
} DestoryingRelationshipResponseMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = DestoryingRelationshipResponseMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(DestoryingRelationshipResponseMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "sponsorAccount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = DestoryingRelationshipResponseMessage_FieldNumber_SponsorAccount,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(DestoryingRelationshipResponseMessage__storage_, sponsorAccount),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "targetAccount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = DestoryingRelationshipResponseMessage_FieldNumber_TargetAccount,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(DestoryingRelationshipResponseMessage__storage_, targetAccount),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_DestoryingRelationshipResponseSuccess,
        .core.name = "response",
        .core.dataTypeSpecific.enumDescFunc = DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_EnumDescriptor,
        .core.number = DestoryingRelationshipResponseMessage_FieldNumber_Response,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(DestoryingRelationshipResponseMessage__storage_, response),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DestoryingRelationshipResponseMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(DestoryingRelationshipResponseMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010A\000\002\016\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse

GPBEnumDescriptor *DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "DestoryingRelationshipResponseSuccess\000De"
        "storyingRelationshipResponseFailed\000";
    static const int32_t values[] = {
        DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_DestoryingRelationshipResponseSuccess,
        DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_DestoryingRelationshipResponseFailed,
    };
    static const char *extraTextFormatInfo = "\002\000\036\207\000\001\036\206\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_IsValidValue(int32_t value__) {
  switch (value__) {
    case DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_DestoryingRelationshipResponseSuccess:
    case DestoryingRelationshipResponseMessage_DestoryingRelationshipResponse_DestoryingRelationshipResponseFailed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - FriendListRequestMessage

@implementation FriendListRequestMessage

@dynamic hasSessionId, sessionId;

typedef struct FriendListRequestMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
} FriendListRequestMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = FriendListRequestMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendListRequestMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendListRequestMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendListRequestMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendListItem

@implementation FriendListItem

@dynamic hasFriendAccount, friendAccount;

typedef struct FriendListItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *friendAccount;
} FriendListItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "friendAccount",
        .dataTypeSpecific.className = NULL,
        .number = FriendListItem_FieldNumber_FriendAccount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendListItem__storage_, friendAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendListItem class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendListItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendList

@implementation FriendList

@dynamic itemArray, itemArray_Count;

typedef struct FriendList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemArray;
} FriendList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendListItem),
        .number = FriendList_FieldNumber_ItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FriendList__storage_, itemArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendList class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendListResponseMessage

@implementation FriendListResponseMessage

@dynamic hasSessionId, sessionId;
@dynamic hasFriendList, friendList;

typedef struct FriendListResponseMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  FriendList *friendList;
} FriendListResponseMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = FriendListResponseMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendListResponseMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "friendList",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendList),
        .number = FriendListResponseMessage_FieldNumber_FriendList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendListResponseMessage__storage_, friendList),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendListResponseMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendListResponseMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010A\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OnlineStateMessage

@implementation OnlineStateMessage

@dynamic hasSessionId, sessionId;
@dynamic hasUserAccount, userAccount;
@dynamic hasUserState, userState;

typedef struct OnlineStateMessage__storage_ {
  uint32_t _has_storage_[1];
  OnlineStateMessage_OnlineState userState;
  NSString *sessionId;
  NSString *userAccount;
} OnlineStateMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = OnlineStateMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(OnlineStateMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userAccount",
        .core.dataTypeSpecific.className = NULL,
        .core.number = OnlineStateMessage_FieldNumber_UserAccount,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(OnlineStateMessage__storage_, userAccount),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = OnlineStateMessage_OnlineState_Online,
        .core.name = "userState",
        .core.dataTypeSpecific.enumDescFunc = OnlineStateMessage_OnlineState_EnumDescriptor,
        .core.number = OnlineStateMessage_FieldNumber_UserState,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(OnlineStateMessage__storage_, userState),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OnlineStateMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(OnlineStateMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010A\000\002\013\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum OnlineStateMessage_OnlineState

GPBEnumDescriptor *OnlineStateMessage_OnlineState_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Online\000Offline\000Invisible\000";
    static const int32_t values[] = {
        OnlineStateMessage_OnlineState_Online,
        OnlineStateMessage_OnlineState_Offline,
        OnlineStateMessage_OnlineState_Invisible,
    };
    static const char *extraTextFormatInfo = "\003\000\006\000\001\007\000\002\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OnlineStateMessage_OnlineState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OnlineStateMessage_OnlineState_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OnlineStateMessage_OnlineState_IsValidValue(int32_t value__) {
  switch (value__) {
    case OnlineStateMessage_OnlineState_Online:
    case OnlineStateMessage_OnlineState_Offline:
    case OnlineStateMessage_OnlineState_Invisible:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ChatMessage

@implementation ChatMessage

@dynamic hasSessionId, sessionId;
@dynamic hasSenderAccount, senderAccount;
@dynamic hasReceiverAccount, receiverAccount;
@dynamic hasContent, content;
@dynamic hasTimestamp, timestamp;
@dynamic hasMessageId, messageId;
@dynamic hasMessageIdversion, messageIdversion;

typedef struct ChatMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *senderAccount;
  NSString *receiverAccount;
  NSString *content;
  NSString *timestamp;
  MessageIDVersion *messageIdversion;
  uint64_t messageId;
} ChatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "senderAccount",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_SenderAccount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, senderAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiverAccount",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_ReceiverAccount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, receiverAccount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, content),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Timestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, timestamp),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_MessageId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "messageIdversion",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageIDVersion),
        .number = ChatMessage_FieldNumber_MessageIdversion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, messageIdversion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\010A\000\002\r\000\003\017\000\006\010A\000\007\010b\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotificationMessage

@implementation NotificationMessage

@dynamic hasType, type;
@dynamic hasMessageId, messageId;
@dynamic hasMessageIdversion, messageIdversion;

typedef struct NotificationMessage__storage_ {
  uint32_t _has_storage_[1];
  NotificationMessage_NotificationMessageType type;
  MessageIDVersion *messageIdversion;
  uint64_t messageId;
} NotificationMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = NotificationMessage_NotificationMessageType_SystemNotificationMessageType,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = NotificationMessage_NotificationMessageType_EnumDescriptor,
        .core.number = NotificationMessage_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(NotificationMessage__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "messageId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NotificationMessage_FieldNumber_MessageId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(NotificationMessage__storage_, messageId),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "messageIdversion",
        .core.dataTypeSpecific.className = GPBStringifySymbol(MessageIDVersion),
        .core.number = NotificationMessage_FieldNumber_MessageIdversion,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(NotificationMessage__storage_, messageIdversion),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotificationMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(NotificationMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\010A\000\003\010b\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum NotificationMessage_NotificationMessageType

GPBEnumDescriptor *NotificationMessage_NotificationMessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SystemNotificationMessageType\000";
    static const int32_t values[] = {
        NotificationMessage_NotificationMessageType_SystemNotificationMessageType,
    };
    static const char *extraTextFormatInfo = "\001\000\035\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NotificationMessage_NotificationMessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NotificationMessage_NotificationMessageType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NotificationMessage_NotificationMessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case NotificationMessage_NotificationMessageType_SystemNotificationMessageType:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PullOfflineMessage

@implementation PullOfflineMessage

@dynamic hasSessionId, sessionId;
@dynamic hasMessageId, messageId;
@dynamic hasMessageIdversion, messageIdversion;

typedef struct PullOfflineMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  MessageIDVersion *messageIdversion;
  uint64_t messageId;
} PullOfflineMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = PullOfflineMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PullOfflineMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = PullOfflineMessage_FieldNumber_MessageId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PullOfflineMessage__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "messageIdversion",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageIDVersion),
        .number = PullOfflineMessage_FieldNumber_MessageIdversion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PullOfflineMessage__storage_, messageIdversion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PullOfflineMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PullOfflineMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010A\000\002\010A\000\005\010b\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FetchUserVCardMessage

@implementation FetchUserVCardMessage

@dynamic hasSessionId, sessionId;
@dynamic hasUserId, userId;

typedef struct FetchUserVCardMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *sessionId;
  NSString *userId;
} FetchUserVCardMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = FetchUserVCardMessage_FieldNumber_SessionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FetchUserVCardMessage__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = FetchUserVCardMessage_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FetchUserVCardMessage__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FetchUserVCardMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FetchUserVCardMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010A\000\002\005A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserVCardResponseMessage

@implementation UserVCardResponseMessage

@dynamic hasSessionId, sessionId;
@dynamic hasUserId, userId;
@dynamic hasNickname, nickname;
@dynamic hasGender, gender;
@dynamic hasMood, mood;
@dynamic hasAvator, avator;

typedef struct UserVCardResponseMessage__storage_ {
  uint32_t _has_storage_[1];
  UserGenderType gender;
  NSString *sessionId;
  NSString *userId;
  NSString *nickname;
  NSString *mood;
  NSData *avator;
} UserVCardResponseMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserVCardResponseMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(UserVCardResponseMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "userId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserVCardResponseMessage_FieldNumber_UserId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(UserVCardResponseMessage__storage_, userId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "nickname",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserVCardResponseMessage_FieldNumber_Nickname,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(UserVCardResponseMessage__storage_, nickname),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = UserGenderType_Male,
        .core.name = "gender",
        .core.dataTypeSpecific.enumDescFunc = UserGenderType_EnumDescriptor,
        .core.number = UserVCardResponseMessage_FieldNumber_Gender,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(UserVCardResponseMessage__storage_, gender),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "mood",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserVCardResponseMessage_FieldNumber_Mood,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(UserVCardResponseMessage__storage_, mood),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "avator",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UserVCardResponseMessage_FieldNumber_Avator,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(UserVCardResponseMessage__storage_, avator),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserVCardResponseMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(UserVCardResponseMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010A\000\002\005A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateUserVCardMessage

@implementation UpdateUserVCardMessage

@dynamic hasSessionId, sessionId;
@dynamic hasNickname, nickname;
@dynamic hasGender, gender;
@dynamic hasMood, mood;
@dynamic hasAvator, avator;

typedef struct UpdateUserVCardMessage__storage_ {
  uint32_t _has_storage_[1];
  UserGenderType gender;
  NSString *sessionId;
  NSString *nickname;
  NSString *mood;
  NSData *avator;
} UpdateUserVCardMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UpdateUserVCardMessage_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(UpdateUserVCardMessage__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "nickname",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UpdateUserVCardMessage_FieldNumber_Nickname,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(UpdateUserVCardMessage__storage_, nickname),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = UserGenderType_Male,
        .core.name = "gender",
        .core.dataTypeSpecific.enumDescFunc = UserGenderType_EnumDescriptor,
        .core.number = UpdateUserVCardMessage_FieldNumber_Gender,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(UpdateUserVCardMessage__storage_, gender),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "mood",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UpdateUserVCardMessage_FieldNumber_Mood,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(UpdateUserVCardMessage__storage_, mood),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "avator",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UpdateUserVCardMessage_FieldNumber_Avator,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(UpdateUserVCardMessage__storage_, avator),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateUserVCardMessage class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(UpdateUserVCardMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateUserVCardMessageResponse

@implementation UpdateUserVCardMessageResponse

@dynamic hasSessionId, sessionId;
@dynamic hasState, state;

typedef struct UpdateUserVCardMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  UpdateUserVCardMessageResponse_UpdateUserVCardStateType state;
  NSString *sessionId;
} UpdateUserVCardMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "sessionId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = UpdateUserVCardMessageResponse_FieldNumber_SessionId,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(UpdateUserVCardMessageResponse__storage_, sessionId),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = UpdateUserVCardMessageResponse_UpdateUserVCardStateType_Success,
        .core.name = "state",
        .core.dataTypeSpecific.enumDescFunc = UpdateUserVCardMessageResponse_UpdateUserVCardStateType_EnumDescriptor,
        .core.number = UpdateUserVCardMessageResponse_FieldNumber_State,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(UpdateUserVCardMessageResponse__storage_, state),
        .core.flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateUserVCardMessageResponse class]
                                     rootClass:[KakaImmessageRoot class]
                                          file:KakaImmessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(UpdateUserVCardMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum UpdateUserVCardMessageResponse_UpdateUserVCardStateType

GPBEnumDescriptor *UpdateUserVCardMessageResponse_UpdateUserVCardStateType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Failure\000";
    static const int32_t values[] = {
        UpdateUserVCardMessageResponse_UpdateUserVCardStateType_Success,
        UpdateUserVCardMessageResponse_UpdateUserVCardStateType_Failure,
    };
    static const char *extraTextFormatInfo = "\002\000\007\000\001\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UpdateUserVCardMessageResponse_UpdateUserVCardStateType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UpdateUserVCardMessageResponse_UpdateUserVCardStateType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UpdateUserVCardMessageResponse_UpdateUserVCardStateType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UpdateUserVCardMessageResponse_UpdateUserVCardStateType_Success:
    case UpdateUserVCardMessageResponse_UpdateUserVCardStateType_Failure:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
