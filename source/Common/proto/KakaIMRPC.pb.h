// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KakaIMRPC.proto

#ifndef PROTOBUF_KakaIMRPC_2eproto__INCLUDED
#define PROTOBUF_KakaIMRPC_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_KakaIMRPC_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAuthenticationRequestImpl();
void InitDefaultsAuthenticationRequest();
void InitDefaultsAuthenticationResponseImpl();
void InitDefaultsAuthenticationResponse();
void InitDefaultsFriendListRequestMessageImpl();
void InitDefaultsFriendListRequestMessage();
void InitDefaultsFriendListItemImpl();
void InitDefaultsFriendListItem();
void InitDefaultsFriendListResponseMessageImpl();
void InitDefaultsFriendListResponseMessage();
inline void InitDefaults() {
  InitDefaultsAuthenticationRequest();
  InitDefaultsAuthenticationResponse();
  InitDefaultsFriendListRequestMessage();
  InitDefaultsFriendListItem();
  InitDefaultsFriendListResponseMessage();
}
}  // namespace protobuf_KakaIMRPC_2eproto
namespace kakaIM {
namespace rpc {
class AuthenticationRequest;
class AuthenticationRequestDefaultTypeInternal;
extern AuthenticationRequestDefaultTypeInternal _AuthenticationRequest_default_instance_;
class AuthenticationResponse;
class AuthenticationResponseDefaultTypeInternal;
extern AuthenticationResponseDefaultTypeInternal _AuthenticationResponse_default_instance_;
class FriendListItem;
class FriendListItemDefaultTypeInternal;
extern FriendListItemDefaultTypeInternal _FriendListItem_default_instance_;
class FriendListRequestMessage;
class FriendListRequestMessageDefaultTypeInternal;
extern FriendListRequestMessageDefaultTypeInternal _FriendListRequestMessage_default_instance_;
class FriendListResponseMessage;
class FriendListResponseMessageDefaultTypeInternal;
extern FriendListResponseMessageDefaultTypeInternal _FriendListResponseMessage_default_instance_;
}  // namespace rpc
}  // namespace kakaIM
namespace kakaIM {
namespace rpc {

enum AuthenticationResponse_Status {
  AuthenticationResponse_Status_Success = 1,
  AuthenticationResponse_Status_Failed = 2
};
bool AuthenticationResponse_Status_IsValid(int value);
const AuthenticationResponse_Status AuthenticationResponse_Status_Status_MIN = AuthenticationResponse_Status_Success;
const AuthenticationResponse_Status AuthenticationResponse_Status_Status_MAX = AuthenticationResponse_Status_Failed;
const int AuthenticationResponse_Status_Status_ARRAYSIZE = AuthenticationResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthenticationResponse_Status_descriptor();
inline const ::std::string& AuthenticationResponse_Status_Name(AuthenticationResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthenticationResponse_Status_descriptor(), value);
}
inline bool AuthenticationResponse_Status_Parse(
    const ::std::string& name, AuthenticationResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthenticationResponse_Status>(
    AuthenticationResponse_Status_descriptor(), name, value);
}
enum AuthenticationResponse_FailureType {
  AuthenticationResponse_FailureType_WrongAccountOrPassword = 1,
  AuthenticationResponse_FailureType_ServerInternalError = 2
};
bool AuthenticationResponse_FailureType_IsValid(int value);
const AuthenticationResponse_FailureType AuthenticationResponse_FailureType_FailureType_MIN = AuthenticationResponse_FailureType_WrongAccountOrPassword;
const AuthenticationResponse_FailureType AuthenticationResponse_FailureType_FailureType_MAX = AuthenticationResponse_FailureType_ServerInternalError;
const int AuthenticationResponse_FailureType_FailureType_ARRAYSIZE = AuthenticationResponse_FailureType_FailureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthenticationResponse_FailureType_descriptor();
inline const ::std::string& AuthenticationResponse_FailureType_Name(AuthenticationResponse_FailureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthenticationResponse_FailureType_descriptor(), value);
}
inline bool AuthenticationResponse_FailureType_Parse(
    const ::std::string& name, AuthenticationResponse_FailureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthenticationResponse_FailureType>(
    AuthenticationResponse_FailureType_descriptor(), name, value);
}
enum FriendListResponseMessage_Status {
  FriendListResponseMessage_Status_Success = 1,
  FriendListResponseMessage_Status_SuccessButNoNewChange = 2,
  FriendListResponseMessage_Status_Failed = 3
};
bool FriendListResponseMessage_Status_IsValid(int value);
const FriendListResponseMessage_Status FriendListResponseMessage_Status_Status_MIN = FriendListResponseMessage_Status_Success;
const FriendListResponseMessage_Status FriendListResponseMessage_Status_Status_MAX = FriendListResponseMessage_Status_Failed;
const int FriendListResponseMessage_Status_Status_ARRAYSIZE = FriendListResponseMessage_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* FriendListResponseMessage_Status_descriptor();
inline const ::std::string& FriendListResponseMessage_Status_Name(FriendListResponseMessage_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    FriendListResponseMessage_Status_descriptor(), value);
}
inline bool FriendListResponseMessage_Status_Parse(
    const ::std::string& name, FriendListResponseMessage_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FriendListResponseMessage_Status>(
    FriendListResponseMessage_Status_descriptor(), name, value);
}
enum FriendListResponseMessage_FailureType {
  FriendListResponseMessage_FailureType_ServerInternalError = 1,
  FriendListResponseMessage_FailureType_RecordNotExist = 2
};
bool FriendListResponseMessage_FailureType_IsValid(int value);
const FriendListResponseMessage_FailureType FriendListResponseMessage_FailureType_FailureType_MIN = FriendListResponseMessage_FailureType_ServerInternalError;
const FriendListResponseMessage_FailureType FriendListResponseMessage_FailureType_FailureType_MAX = FriendListResponseMessage_FailureType_RecordNotExist;
const int FriendListResponseMessage_FailureType_FailureType_ARRAYSIZE = FriendListResponseMessage_FailureType_FailureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FriendListResponseMessage_FailureType_descriptor();
inline const ::std::string& FriendListResponseMessage_FailureType_Name(FriendListResponseMessage_FailureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FriendListResponseMessage_FailureType_descriptor(), value);
}
inline bool FriendListResponseMessage_FailureType_Parse(
    const ::std::string& name, FriendListResponseMessage_FailureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FriendListResponseMessage_FailureType>(
    FriendListResponseMessage_FailureType_descriptor(), name, value);
}
// ===================================================================

class AuthenticationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.rpc.AuthenticationRequest) */ {
 public:
  AuthenticationRequest();
  virtual ~AuthenticationRequest();

  AuthenticationRequest(const AuthenticationRequest& from);

  inline AuthenticationRequest& operator=(const AuthenticationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticationRequest(AuthenticationRequest&& from) noexcept
    : AuthenticationRequest() {
    *this = ::std::move(from);
  }

  inline AuthenticationRequest& operator=(AuthenticationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticationRequest* internal_default_instance() {
    return reinterpret_cast<const AuthenticationRequest*>(
               &_AuthenticationRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AuthenticationRequest* other);
  friend void swap(AuthenticationRequest& a, AuthenticationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticationRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthenticationRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthenticationRequest& from);
  void MergeFrom(const AuthenticationRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthenticationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userAccount = 1;
  bool has_useraccount() const;
  void clear_useraccount();
  static const int kUserAccountFieldNumber = 1;
  const ::std::string& useraccount() const;
  void set_useraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_useraccount(::std::string&& value);
  #endif
  void set_useraccount(const char* value);
  void set_useraccount(const char* value, size_t size);
  ::std::string* mutable_useraccount();
  ::std::string* release_useraccount();
  void set_allocated_useraccount(::std::string* useraccount);

  // required string userPassword = 2;
  bool has_userpassword() const;
  void clear_userpassword();
  static const int kUserPasswordFieldNumber = 2;
  const ::std::string& userpassword() const;
  void set_userpassword(const ::std::string& value);
  #if LANG_CXX11
  void set_userpassword(::std::string&& value);
  #endif
  void set_userpassword(const char* value);
  void set_userpassword(const char* value, size_t size);
  ::std::string* mutable_userpassword();
  ::std::string* release_userpassword();
  void set_allocated_userpassword(::std::string* userpassword);

  // @@protoc_insertion_point(class_scope:kakaIM.rpc.AuthenticationRequest)
 private:
  void set_has_useraccount();
  void clear_has_useraccount();
  void set_has_userpassword();
  void clear_has_userpassword();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr useraccount_;
  ::google::protobuf::internal::ArenaStringPtr userpassword_;
  friend struct ::protobuf_KakaIMRPC_2eproto::TableStruct;
  friend void ::protobuf_KakaIMRPC_2eproto::InitDefaultsAuthenticationRequestImpl();
};
// -------------------------------------------------------------------

class AuthenticationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.rpc.AuthenticationResponse) */ {
 public:
  AuthenticationResponse();
  virtual ~AuthenticationResponse();

  AuthenticationResponse(const AuthenticationResponse& from);

  inline AuthenticationResponse& operator=(const AuthenticationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthenticationResponse(AuthenticationResponse&& from) noexcept
    : AuthenticationResponse() {
    *this = ::std::move(from);
  }

  inline AuthenticationResponse& operator=(AuthenticationResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthenticationResponse* internal_default_instance() {
    return reinterpret_cast<const AuthenticationResponse*>(
               &_AuthenticationResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AuthenticationResponse* other);
  friend void swap(AuthenticationResponse& a, AuthenticationResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthenticationResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthenticationResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthenticationResponse& from);
  void MergeFrom(const AuthenticationResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthenticationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AuthenticationResponse_Status Status;
  static const Status Success =
    AuthenticationResponse_Status_Success;
  static const Status Failed =
    AuthenticationResponse_Status_Failed;
  static inline bool Status_IsValid(int value) {
    return AuthenticationResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    AuthenticationResponse_Status_Status_MIN;
  static const Status Status_MAX =
    AuthenticationResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    AuthenticationResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return AuthenticationResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return AuthenticationResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return AuthenticationResponse_Status_Parse(name, value);
  }

  typedef AuthenticationResponse_FailureType FailureType;
  static const FailureType WrongAccountOrPassword =
    AuthenticationResponse_FailureType_WrongAccountOrPassword;
  static const FailureType ServerInternalError =
    AuthenticationResponse_FailureType_ServerInternalError;
  static inline bool FailureType_IsValid(int value) {
    return AuthenticationResponse_FailureType_IsValid(value);
  }
  static const FailureType FailureType_MIN =
    AuthenticationResponse_FailureType_FailureType_MIN;
  static const FailureType FailureType_MAX =
    AuthenticationResponse_FailureType_FailureType_MAX;
  static const int FailureType_ARRAYSIZE =
    AuthenticationResponse_FailureType_FailureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailureType_descriptor() {
    return AuthenticationResponse_FailureType_descriptor();
  }
  static inline const ::std::string& FailureType_Name(FailureType value) {
    return AuthenticationResponse_FailureType_Name(value);
  }
  static inline bool FailureType_Parse(const ::std::string& name,
      FailureType* value) {
    return AuthenticationResponse_FailureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string userAccount = 1;
  bool has_useraccount() const;
  void clear_useraccount();
  static const int kUserAccountFieldNumber = 1;
  const ::std::string& useraccount() const;
  void set_useraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_useraccount(::std::string&& value);
  #endif
  void set_useraccount(const char* value);
  void set_useraccount(const char* value, size_t size);
  ::std::string* mutable_useraccount();
  ::std::string* release_useraccount();
  void set_allocated_useraccount(::std::string* useraccount);

  // required .kakaIM.rpc.AuthenticationResponse.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::kakaIM::rpc::AuthenticationResponse_Status status() const;
  void set_status(::kakaIM::rpc::AuthenticationResponse_Status value);

  // optional .kakaIM.rpc.AuthenticationResponse.FailureType failureError = 3;
  bool has_failureerror() const;
  void clear_failureerror();
  static const int kFailureErrorFieldNumber = 3;
  ::kakaIM::rpc::AuthenticationResponse_FailureType failureerror() const;
  void set_failureerror(::kakaIM::rpc::AuthenticationResponse_FailureType value);

  // @@protoc_insertion_point(class_scope:kakaIM.rpc.AuthenticationResponse)
 private:
  void set_has_useraccount();
  void clear_has_useraccount();
  void set_has_status();
  void clear_has_status();
  void set_has_failureerror();
  void clear_has_failureerror();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr useraccount_;
  int status_;
  int failureerror_;
  friend struct ::protobuf_KakaIMRPC_2eproto::TableStruct;
  friend void ::protobuf_KakaIMRPC_2eproto::InitDefaultsAuthenticationResponseImpl();
};
// -------------------------------------------------------------------

class FriendListRequestMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.rpc.FriendListRequestMessage) */ {
 public:
  FriendListRequestMessage();
  virtual ~FriendListRequestMessage();

  FriendListRequestMessage(const FriendListRequestMessage& from);

  inline FriendListRequestMessage& operator=(const FriendListRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FriendListRequestMessage(FriendListRequestMessage&& from) noexcept
    : FriendListRequestMessage() {
    *this = ::std::move(from);
  }

  inline FriendListRequestMessage& operator=(FriendListRequestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendListRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FriendListRequestMessage* internal_default_instance() {
    return reinterpret_cast<const FriendListRequestMessage*>(
               &_FriendListRequestMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FriendListRequestMessage* other);
  friend void swap(FriendListRequestMessage& a, FriendListRequestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FriendListRequestMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  FriendListRequestMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FriendListRequestMessage& from);
  void MergeFrom(const FriendListRequestMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FriendListRequestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userAccount = 1;
  bool has_useraccount() const;
  void clear_useraccount();
  static const int kUserAccountFieldNumber = 1;
  const ::std::string& useraccount() const;
  void set_useraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_useraccount(::std::string&& value);
  #endif
  void set_useraccount(const char* value);
  void set_useraccount(const char* value, size_t size);
  ::std::string* mutable_useraccount();
  ::std::string* release_useraccount();
  void set_allocated_useraccount(::std::string* useraccount);

  // required uint64 currentVersion = 2;
  bool has_currentversion() const;
  void clear_currentversion();
  static const int kCurrentVersionFieldNumber = 2;
  ::google::protobuf::uint64 currentversion() const;
  void set_currentversion(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kakaIM.rpc.FriendListRequestMessage)
 private:
  void set_has_useraccount();
  void clear_has_useraccount();
  void set_has_currentversion();
  void clear_has_currentversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr useraccount_;
  ::google::protobuf::uint64 currentversion_;
  friend struct ::protobuf_KakaIMRPC_2eproto::TableStruct;
  friend void ::protobuf_KakaIMRPC_2eproto::InitDefaultsFriendListRequestMessageImpl();
};
// -------------------------------------------------------------------

class FriendListItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.rpc.FriendListItem) */ {
 public:
  FriendListItem();
  virtual ~FriendListItem();

  FriendListItem(const FriendListItem& from);

  inline FriendListItem& operator=(const FriendListItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FriendListItem(FriendListItem&& from) noexcept
    : FriendListItem() {
    *this = ::std::move(from);
  }

  inline FriendListItem& operator=(FriendListItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendListItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FriendListItem* internal_default_instance() {
    return reinterpret_cast<const FriendListItem*>(
               &_FriendListItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FriendListItem* other);
  friend void swap(FriendListItem& a, FriendListItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FriendListItem* New() const PROTOBUF_FINAL { return New(NULL); }

  FriendListItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FriendListItem& from);
  void MergeFrom(const FriendListItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FriendListItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string friendAccount = 1;
  bool has_friendaccount() const;
  void clear_friendaccount();
  static const int kFriendAccountFieldNumber = 1;
  const ::std::string& friendaccount() const;
  void set_friendaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_friendaccount(::std::string&& value);
  #endif
  void set_friendaccount(const char* value);
  void set_friendaccount(const char* value, size_t size);
  ::std::string* mutable_friendaccount();
  ::std::string* release_friendaccount();
  void set_allocated_friendaccount(::std::string* friendaccount);

  // @@protoc_insertion_point(class_scope:kakaIM.rpc.FriendListItem)
 private:
  void set_has_friendaccount();
  void clear_has_friendaccount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr friendaccount_;
  friend struct ::protobuf_KakaIMRPC_2eproto::TableStruct;
  friend void ::protobuf_KakaIMRPC_2eproto::InitDefaultsFriendListItemImpl();
};
// -------------------------------------------------------------------

class FriendListResponseMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.rpc.FriendListResponseMessage) */ {
 public:
  FriendListResponseMessage();
  virtual ~FriendListResponseMessage();

  FriendListResponseMessage(const FriendListResponseMessage& from);

  inline FriendListResponseMessage& operator=(const FriendListResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FriendListResponseMessage(FriendListResponseMessage&& from) noexcept
    : FriendListResponseMessage() {
    *this = ::std::move(from);
  }

  inline FriendListResponseMessage& operator=(FriendListResponseMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendListResponseMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FriendListResponseMessage* internal_default_instance() {
    return reinterpret_cast<const FriendListResponseMessage*>(
               &_FriendListResponseMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(FriendListResponseMessage* other);
  friend void swap(FriendListResponseMessage& a, FriendListResponseMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FriendListResponseMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  FriendListResponseMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FriendListResponseMessage& from);
  void MergeFrom(const FriendListResponseMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FriendListResponseMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FriendListResponseMessage_Status Status;
  static const Status Success =
    FriendListResponseMessage_Status_Success;
  static const Status SuccessButNoNewChange =
    FriendListResponseMessage_Status_SuccessButNoNewChange;
  static const Status Failed =
    FriendListResponseMessage_Status_Failed;
  static inline bool Status_IsValid(int value) {
    return FriendListResponseMessage_Status_IsValid(value);
  }
  static const Status Status_MIN =
    FriendListResponseMessage_Status_Status_MIN;
  static const Status Status_MAX =
    FriendListResponseMessage_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    FriendListResponseMessage_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return FriendListResponseMessage_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return FriendListResponseMessage_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return FriendListResponseMessage_Status_Parse(name, value);
  }

  typedef FriendListResponseMessage_FailureType FailureType;
  static const FailureType ServerInternalError =
    FriendListResponseMessage_FailureType_ServerInternalError;
  static const FailureType RecordNotExist =
    FriendListResponseMessage_FailureType_RecordNotExist;
  static inline bool FailureType_IsValid(int value) {
    return FriendListResponseMessage_FailureType_IsValid(value);
  }
  static const FailureType FailureType_MIN =
    FriendListResponseMessage_FailureType_FailureType_MIN;
  static const FailureType FailureType_MAX =
    FriendListResponseMessage_FailureType_FailureType_MAX;
  static const int FailureType_ARRAYSIZE =
    FriendListResponseMessage_FailureType_FailureType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailureType_descriptor() {
    return FriendListResponseMessage_FailureType_descriptor();
  }
  static inline const ::std::string& FailureType_Name(FailureType value) {
    return FriendListResponseMessage_FailureType_Name(value);
  }
  static inline bool FailureType_Parse(const ::std::string& name,
      FailureType* value) {
    return FriendListResponseMessage_FailureType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .kakaIM.rpc.FriendListItem friend = 5;
  int friend__size() const;
  void clear_friend_();
  static const int kFriendFieldNumber = 5;
  const ::kakaIM::rpc::FriendListItem& friend_(int index) const;
  ::kakaIM::rpc::FriendListItem* mutable_friend_(int index);
  ::kakaIM::rpc::FriendListItem* add_friend_();
  ::google::protobuf::RepeatedPtrField< ::kakaIM::rpc::FriendListItem >*
      mutable_friend_();
  const ::google::protobuf::RepeatedPtrField< ::kakaIM::rpc::FriendListItem >&
      friend_() const;

  // required string userAccount = 1;
  bool has_useraccount() const;
  void clear_useraccount();
  static const int kUserAccountFieldNumber = 1;
  const ::std::string& useraccount() const;
  void set_useraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_useraccount(::std::string&& value);
  #endif
  void set_useraccount(const char* value);
  void set_useraccount(const char* value, size_t size);
  ::std::string* mutable_useraccount();
  ::std::string* release_useraccount();
  void set_allocated_useraccount(::std::string* useraccount);

  // optional uint64 currentVersion = 4;
  bool has_currentversion() const;
  void clear_currentversion();
  static const int kCurrentVersionFieldNumber = 4;
  ::google::protobuf::uint64 currentversion() const;
  void set_currentversion(::google::protobuf::uint64 value);

  // required .kakaIM.rpc.FriendListResponseMessage.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::kakaIM::rpc::FriendListResponseMessage_Status status() const;
  void set_status(::kakaIM::rpc::FriendListResponseMessage_Status value);

  // optional .kakaIM.rpc.FriendListResponseMessage.FailureType failureError = 3;
  bool has_failureerror() const;
  void clear_failureerror();
  static const int kFailureErrorFieldNumber = 3;
  ::kakaIM::rpc::FriendListResponseMessage_FailureType failureerror() const;
  void set_failureerror(::kakaIM::rpc::FriendListResponseMessage_FailureType value);

  // @@protoc_insertion_point(class_scope:kakaIM.rpc.FriendListResponseMessage)
 private:
  void set_has_useraccount();
  void clear_has_useraccount();
  void set_has_status();
  void clear_has_status();
  void set_has_failureerror();
  void clear_has_failureerror();
  void set_has_currentversion();
  void clear_has_currentversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kakaIM::rpc::FriendListItem > friend__;
  ::google::protobuf::internal::ArenaStringPtr useraccount_;
  ::google::protobuf::uint64 currentversion_;
  int status_;
  int failureerror_;
  friend struct ::protobuf_KakaIMRPC_2eproto::TableStruct;
  friend void ::protobuf_KakaIMRPC_2eproto::InitDefaultsFriendListResponseMessageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuthenticationRequest

// required string userAccount = 1;
inline bool AuthenticationRequest::has_useraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticationRequest::set_has_useraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticationRequest::clear_has_useraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticationRequest::clear_useraccount() {
  useraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_useraccount();
}
inline const ::std::string& AuthenticationRequest::useraccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.AuthenticationRequest.userAccount)
  return useraccount_.GetNoArena();
}
inline void AuthenticationRequest::set_useraccount(const ::std::string& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.rpc.AuthenticationRequest.userAccount)
}
#if LANG_CXX11
inline void AuthenticationRequest::set_useraccount(::std::string&& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.rpc.AuthenticationRequest.userAccount)
}
#endif
inline void AuthenticationRequest::set_useraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.rpc.AuthenticationRequest.userAccount)
}
inline void AuthenticationRequest::set_useraccount(const char* value, size_t size) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.rpc.AuthenticationRequest.userAccount)
}
inline ::std::string* AuthenticationRequest::mutable_useraccount() {
  set_has_useraccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.rpc.AuthenticationRequest.userAccount)
  return useraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticationRequest::release_useraccount() {
  // @@protoc_insertion_point(field_release:kakaIM.rpc.AuthenticationRequest.userAccount)
  clear_has_useraccount();
  return useraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticationRequest::set_allocated_useraccount(::std::string* useraccount) {
  if (useraccount != NULL) {
    set_has_useraccount();
  } else {
    clear_has_useraccount();
  }
  useraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), useraccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.rpc.AuthenticationRequest.userAccount)
}

// required string userPassword = 2;
inline bool AuthenticationRequest::has_userpassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticationRequest::set_has_userpassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticationRequest::clear_has_userpassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticationRequest::clear_userpassword() {
  userpassword_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userpassword();
}
inline const ::std::string& AuthenticationRequest::userpassword() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.AuthenticationRequest.userPassword)
  return userpassword_.GetNoArena();
}
inline void AuthenticationRequest::set_userpassword(const ::std::string& value) {
  set_has_userpassword();
  userpassword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.rpc.AuthenticationRequest.userPassword)
}
#if LANG_CXX11
inline void AuthenticationRequest::set_userpassword(::std::string&& value) {
  set_has_userpassword();
  userpassword_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.rpc.AuthenticationRequest.userPassword)
}
#endif
inline void AuthenticationRequest::set_userpassword(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userpassword();
  userpassword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.rpc.AuthenticationRequest.userPassword)
}
inline void AuthenticationRequest::set_userpassword(const char* value, size_t size) {
  set_has_userpassword();
  userpassword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.rpc.AuthenticationRequest.userPassword)
}
inline ::std::string* AuthenticationRequest::mutable_userpassword() {
  set_has_userpassword();
  // @@protoc_insertion_point(field_mutable:kakaIM.rpc.AuthenticationRequest.userPassword)
  return userpassword_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticationRequest::release_userpassword() {
  // @@protoc_insertion_point(field_release:kakaIM.rpc.AuthenticationRequest.userPassword)
  clear_has_userpassword();
  return userpassword_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticationRequest::set_allocated_userpassword(::std::string* userpassword) {
  if (userpassword != NULL) {
    set_has_userpassword();
  } else {
    clear_has_userpassword();
  }
  userpassword_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userpassword);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.rpc.AuthenticationRequest.userPassword)
}

// -------------------------------------------------------------------

// AuthenticationResponse

// required string userAccount = 1;
inline bool AuthenticationResponse::has_useraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticationResponse::set_has_useraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticationResponse::clear_has_useraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticationResponse::clear_useraccount() {
  useraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_useraccount();
}
inline const ::std::string& AuthenticationResponse::useraccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.AuthenticationResponse.userAccount)
  return useraccount_.GetNoArena();
}
inline void AuthenticationResponse::set_useraccount(const ::std::string& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.rpc.AuthenticationResponse.userAccount)
}
#if LANG_CXX11
inline void AuthenticationResponse::set_useraccount(::std::string&& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.rpc.AuthenticationResponse.userAccount)
}
#endif
inline void AuthenticationResponse::set_useraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.rpc.AuthenticationResponse.userAccount)
}
inline void AuthenticationResponse::set_useraccount(const char* value, size_t size) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.rpc.AuthenticationResponse.userAccount)
}
inline ::std::string* AuthenticationResponse::mutable_useraccount() {
  set_has_useraccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.rpc.AuthenticationResponse.userAccount)
  return useraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthenticationResponse::release_useraccount() {
  // @@protoc_insertion_point(field_release:kakaIM.rpc.AuthenticationResponse.userAccount)
  clear_has_useraccount();
  return useraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthenticationResponse::set_allocated_useraccount(::std::string* useraccount) {
  if (useraccount != NULL) {
    set_has_useraccount();
  } else {
    clear_has_useraccount();
  }
  useraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), useraccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.rpc.AuthenticationResponse.userAccount)
}

// required .kakaIM.rpc.AuthenticationResponse.Status status = 2;
inline bool AuthenticationResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticationResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticationResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticationResponse::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::kakaIM::rpc::AuthenticationResponse_Status AuthenticationResponse::status() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.AuthenticationResponse.status)
  return static_cast< ::kakaIM::rpc::AuthenticationResponse_Status >(status_);
}
inline void AuthenticationResponse::set_status(::kakaIM::rpc::AuthenticationResponse_Status value) {
  assert(::kakaIM::rpc::AuthenticationResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.rpc.AuthenticationResponse.status)
}

// optional .kakaIM.rpc.AuthenticationResponse.FailureType failureError = 3;
inline bool AuthenticationResponse::has_failureerror() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticationResponse::set_has_failureerror() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticationResponse::clear_has_failureerror() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticationResponse::clear_failureerror() {
  failureerror_ = 1;
  clear_has_failureerror();
}
inline ::kakaIM::rpc::AuthenticationResponse_FailureType AuthenticationResponse::failureerror() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.AuthenticationResponse.failureError)
  return static_cast< ::kakaIM::rpc::AuthenticationResponse_FailureType >(failureerror_);
}
inline void AuthenticationResponse::set_failureerror(::kakaIM::rpc::AuthenticationResponse_FailureType value) {
  assert(::kakaIM::rpc::AuthenticationResponse_FailureType_IsValid(value));
  set_has_failureerror();
  failureerror_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.rpc.AuthenticationResponse.failureError)
}

// -------------------------------------------------------------------

// FriendListRequestMessage

// required string userAccount = 1;
inline bool FriendListRequestMessage::has_useraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendListRequestMessage::set_has_useraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendListRequestMessage::clear_has_useraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendListRequestMessage::clear_useraccount() {
  useraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_useraccount();
}
inline const ::std::string& FriendListRequestMessage::useraccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListRequestMessage.userAccount)
  return useraccount_.GetNoArena();
}
inline void FriendListRequestMessage::set_useraccount(const ::std::string& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.rpc.FriendListRequestMessage.userAccount)
}
#if LANG_CXX11
inline void FriendListRequestMessage::set_useraccount(::std::string&& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.rpc.FriendListRequestMessage.userAccount)
}
#endif
inline void FriendListRequestMessage::set_useraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.rpc.FriendListRequestMessage.userAccount)
}
inline void FriendListRequestMessage::set_useraccount(const char* value, size_t size) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.rpc.FriendListRequestMessage.userAccount)
}
inline ::std::string* FriendListRequestMessage::mutable_useraccount() {
  set_has_useraccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.rpc.FriendListRequestMessage.userAccount)
  return useraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FriendListRequestMessage::release_useraccount() {
  // @@protoc_insertion_point(field_release:kakaIM.rpc.FriendListRequestMessage.userAccount)
  clear_has_useraccount();
  return useraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FriendListRequestMessage::set_allocated_useraccount(::std::string* useraccount) {
  if (useraccount != NULL) {
    set_has_useraccount();
  } else {
    clear_has_useraccount();
  }
  useraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), useraccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.rpc.FriendListRequestMessage.userAccount)
}

// required uint64 currentVersion = 2;
inline bool FriendListRequestMessage::has_currentversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendListRequestMessage::set_has_currentversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendListRequestMessage::clear_has_currentversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendListRequestMessage::clear_currentversion() {
  currentversion_ = GOOGLE_ULONGLONG(0);
  clear_has_currentversion();
}
inline ::google::protobuf::uint64 FriendListRequestMessage::currentversion() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListRequestMessage.currentVersion)
  return currentversion_;
}
inline void FriendListRequestMessage::set_currentversion(::google::protobuf::uint64 value) {
  set_has_currentversion();
  currentversion_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.rpc.FriendListRequestMessage.currentVersion)
}

// -------------------------------------------------------------------

// FriendListItem

// required string friendAccount = 1;
inline bool FriendListItem::has_friendaccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendListItem::set_has_friendaccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendListItem::clear_has_friendaccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendListItem::clear_friendaccount() {
  friendaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_friendaccount();
}
inline const ::std::string& FriendListItem::friendaccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListItem.friendAccount)
  return friendaccount_.GetNoArena();
}
inline void FriendListItem::set_friendaccount(const ::std::string& value) {
  set_has_friendaccount();
  friendaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.rpc.FriendListItem.friendAccount)
}
#if LANG_CXX11
inline void FriendListItem::set_friendaccount(::std::string&& value) {
  set_has_friendaccount();
  friendaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.rpc.FriendListItem.friendAccount)
}
#endif
inline void FriendListItem::set_friendaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_friendaccount();
  friendaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.rpc.FriendListItem.friendAccount)
}
inline void FriendListItem::set_friendaccount(const char* value, size_t size) {
  set_has_friendaccount();
  friendaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.rpc.FriendListItem.friendAccount)
}
inline ::std::string* FriendListItem::mutable_friendaccount() {
  set_has_friendaccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.rpc.FriendListItem.friendAccount)
  return friendaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FriendListItem::release_friendaccount() {
  // @@protoc_insertion_point(field_release:kakaIM.rpc.FriendListItem.friendAccount)
  clear_has_friendaccount();
  return friendaccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FriendListItem::set_allocated_friendaccount(::std::string* friendaccount) {
  if (friendaccount != NULL) {
    set_has_friendaccount();
  } else {
    clear_has_friendaccount();
  }
  friendaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendaccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.rpc.FriendListItem.friendAccount)
}

// -------------------------------------------------------------------

// FriendListResponseMessage

// required string userAccount = 1;
inline bool FriendListResponseMessage::has_useraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendListResponseMessage::set_has_useraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendListResponseMessage::clear_has_useraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendListResponseMessage::clear_useraccount() {
  useraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_useraccount();
}
inline const ::std::string& FriendListResponseMessage::useraccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListResponseMessage.userAccount)
  return useraccount_.GetNoArena();
}
inline void FriendListResponseMessage::set_useraccount(const ::std::string& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.rpc.FriendListResponseMessage.userAccount)
}
#if LANG_CXX11
inline void FriendListResponseMessage::set_useraccount(::std::string&& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.rpc.FriendListResponseMessage.userAccount)
}
#endif
inline void FriendListResponseMessage::set_useraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.rpc.FriendListResponseMessage.userAccount)
}
inline void FriendListResponseMessage::set_useraccount(const char* value, size_t size) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.rpc.FriendListResponseMessage.userAccount)
}
inline ::std::string* FriendListResponseMessage::mutable_useraccount() {
  set_has_useraccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.rpc.FriendListResponseMessage.userAccount)
  return useraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FriendListResponseMessage::release_useraccount() {
  // @@protoc_insertion_point(field_release:kakaIM.rpc.FriendListResponseMessage.userAccount)
  clear_has_useraccount();
  return useraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FriendListResponseMessage::set_allocated_useraccount(::std::string* useraccount) {
  if (useraccount != NULL) {
    set_has_useraccount();
  } else {
    clear_has_useraccount();
  }
  useraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), useraccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.rpc.FriendListResponseMessage.userAccount)
}

// required .kakaIM.rpc.FriendListResponseMessage.Status status = 2;
inline bool FriendListResponseMessage::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendListResponseMessage::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendListResponseMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendListResponseMessage::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::kakaIM::rpc::FriendListResponseMessage_Status FriendListResponseMessage::status() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListResponseMessage.status)
  return static_cast< ::kakaIM::rpc::FriendListResponseMessage_Status >(status_);
}
inline void FriendListResponseMessage::set_status(::kakaIM::rpc::FriendListResponseMessage_Status value) {
  assert(::kakaIM::rpc::FriendListResponseMessage_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.rpc.FriendListResponseMessage.status)
}

// optional .kakaIM.rpc.FriendListResponseMessage.FailureType failureError = 3;
inline bool FriendListResponseMessage::has_failureerror() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendListResponseMessage::set_has_failureerror() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendListResponseMessage::clear_has_failureerror() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendListResponseMessage::clear_failureerror() {
  failureerror_ = 1;
  clear_has_failureerror();
}
inline ::kakaIM::rpc::FriendListResponseMessage_FailureType FriendListResponseMessage::failureerror() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListResponseMessage.failureError)
  return static_cast< ::kakaIM::rpc::FriendListResponseMessage_FailureType >(failureerror_);
}
inline void FriendListResponseMessage::set_failureerror(::kakaIM::rpc::FriendListResponseMessage_FailureType value) {
  assert(::kakaIM::rpc::FriendListResponseMessage_FailureType_IsValid(value));
  set_has_failureerror();
  failureerror_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.rpc.FriendListResponseMessage.failureError)
}

// optional uint64 currentVersion = 4;
inline bool FriendListResponseMessage::has_currentversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendListResponseMessage::set_has_currentversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendListResponseMessage::clear_has_currentversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendListResponseMessage::clear_currentversion() {
  currentversion_ = GOOGLE_ULONGLONG(0);
  clear_has_currentversion();
}
inline ::google::protobuf::uint64 FriendListResponseMessage::currentversion() const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListResponseMessage.currentVersion)
  return currentversion_;
}
inline void FriendListResponseMessage::set_currentversion(::google::protobuf::uint64 value) {
  set_has_currentversion();
  currentversion_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.rpc.FriendListResponseMessage.currentVersion)
}

// repeated .kakaIM.rpc.FriendListItem friend = 5;
inline int FriendListResponseMessage::friend__size() const {
  return friend__.size();
}
inline void FriendListResponseMessage::clear_friend_() {
  friend__.Clear();
}
inline const ::kakaIM::rpc::FriendListItem& FriendListResponseMessage::friend_(int index) const {
  // @@protoc_insertion_point(field_get:kakaIM.rpc.FriendListResponseMessage.friend)
  return friend__.Get(index);
}
inline ::kakaIM::rpc::FriendListItem* FriendListResponseMessage::mutable_friend_(int index) {
  // @@protoc_insertion_point(field_mutable:kakaIM.rpc.FriendListResponseMessage.friend)
  return friend__.Mutable(index);
}
inline ::kakaIM::rpc::FriendListItem* FriendListResponseMessage::add_friend_() {
  // @@protoc_insertion_point(field_add:kakaIM.rpc.FriendListResponseMessage.friend)
  return friend__.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kakaIM::rpc::FriendListItem >*
FriendListResponseMessage::mutable_friend_() {
  // @@protoc_insertion_point(field_mutable_list:kakaIM.rpc.FriendListResponseMessage.friend)
  return &friend__;
}
inline const ::google::protobuf::RepeatedPtrField< ::kakaIM::rpc::FriendListItem >&
FriendListResponseMessage::friend_() const {
  // @@protoc_insertion_point(field_list:kakaIM.rpc.FriendListResponseMessage.friend)
  return friend__;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace kakaIM

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kakaIM::rpc::AuthenticationResponse_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kakaIM::rpc::AuthenticationResponse_Status>() {
  return ::kakaIM::rpc::AuthenticationResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::kakaIM::rpc::AuthenticationResponse_FailureType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kakaIM::rpc::AuthenticationResponse_FailureType>() {
  return ::kakaIM::rpc::AuthenticationResponse_FailureType_descriptor();
}
template <> struct is_proto_enum< ::kakaIM::rpc::FriendListResponseMessage_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kakaIM::rpc::FriendListResponseMessage_Status>() {
  return ::kakaIM::rpc::FriendListResponseMessage_Status_descriptor();
}
template <> struct is_proto_enum< ::kakaIM::rpc::FriendListResponseMessage_FailureType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kakaIM::rpc::FriendListResponseMessage_FailureType>() {
  return ::kakaIM::rpc::FriendListResponseMessage_FailureType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_KakaIMRPC_2eproto__INCLUDED
