// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageCluster.proto

#ifndef PROTOBUF_MessageCluster_2eproto__INCLUDED
#define PROTOBUF_MessageCluster_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_MessageCluster_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRequestJoinClusterMessageImpl();
void InitDefaultsRequestJoinClusterMessage();
void InitDefaultsResponseJoinClusterMessageImpl();
void InitDefaultsResponseJoinClusterMessage();
void InitDefaultsHeartBeatMessageImpl();
void InitDefaultsHeartBeatMessage();
void InitDefaultsResponseHeartBeatMessageImpl();
void InitDefaultsResponseHeartBeatMessage();
void InitDefaultsNodeSecessionMessageImpl();
void InitDefaultsNodeSecessionMessage();
void InitDefaultsUserOnlineStateMessageImpl();
void InitDefaultsUserOnlineStateMessage();
void InitDefaultsUpdateUserOnlineStateMessageImpl();
void InitDefaultsUpdateUserOnlineStateMessage();
void InitDefaultsServerMessageImpl();
void InitDefaultsServerMessage();
void InitDefaultsSessionMessageImpl();
void InitDefaultsSessionMessage();
void InitDefaultsRequestMessageIDMessageImpl();
void InitDefaultsRequestMessageIDMessage();
void InitDefaultsResponseMessageIDMessageImpl();
void InitDefaultsResponseMessageIDMessage();
void InitDefaultsNodeLoadInfoMessageImpl();
void InitDefaultsNodeLoadInfoMessage();
inline void InitDefaults() {
  InitDefaultsRequestJoinClusterMessage();
  InitDefaultsResponseJoinClusterMessage();
  InitDefaultsHeartBeatMessage();
  InitDefaultsResponseHeartBeatMessage();
  InitDefaultsNodeSecessionMessage();
  InitDefaultsUserOnlineStateMessage();
  InitDefaultsUpdateUserOnlineStateMessage();
  InitDefaultsServerMessage();
  InitDefaultsSessionMessage();
  InitDefaultsRequestMessageIDMessage();
  InitDefaultsResponseMessageIDMessage();
  InitDefaultsNodeLoadInfoMessage();
}
}  // namespace protobuf_MessageCluster_2eproto
namespace kakaIM {
namespace president {
class HeartBeatMessage;
class HeartBeatMessageDefaultTypeInternal;
extern HeartBeatMessageDefaultTypeInternal _HeartBeatMessage_default_instance_;
class NodeLoadInfoMessage;
class NodeLoadInfoMessageDefaultTypeInternal;
extern NodeLoadInfoMessageDefaultTypeInternal _NodeLoadInfoMessage_default_instance_;
class NodeSecessionMessage;
class NodeSecessionMessageDefaultTypeInternal;
extern NodeSecessionMessageDefaultTypeInternal _NodeSecessionMessage_default_instance_;
class RequestJoinClusterMessage;
class RequestJoinClusterMessageDefaultTypeInternal;
extern RequestJoinClusterMessageDefaultTypeInternal _RequestJoinClusterMessage_default_instance_;
class RequestMessageIDMessage;
class RequestMessageIDMessageDefaultTypeInternal;
extern RequestMessageIDMessageDefaultTypeInternal _RequestMessageIDMessage_default_instance_;
class ResponseHeartBeatMessage;
class ResponseHeartBeatMessageDefaultTypeInternal;
extern ResponseHeartBeatMessageDefaultTypeInternal _ResponseHeartBeatMessage_default_instance_;
class ResponseJoinClusterMessage;
class ResponseJoinClusterMessageDefaultTypeInternal;
extern ResponseJoinClusterMessageDefaultTypeInternal _ResponseJoinClusterMessage_default_instance_;
class ResponseMessageIDMessage;
class ResponseMessageIDMessageDefaultTypeInternal;
extern ResponseMessageIDMessageDefaultTypeInternal _ResponseMessageIDMessage_default_instance_;
class ServerMessage;
class ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class SessionMessage;
class SessionMessageDefaultTypeInternal;
extern SessionMessageDefaultTypeInternal _SessionMessage_default_instance_;
class UpdateUserOnlineStateMessage;
class UpdateUserOnlineStateMessageDefaultTypeInternal;
extern UpdateUserOnlineStateMessageDefaultTypeInternal _UpdateUserOnlineStateMessage_default_instance_;
class UserOnlineStateMessage;
class UserOnlineStateMessageDefaultTypeInternal;
extern UserOnlineStateMessageDefaultTypeInternal _UserOnlineStateMessage_default_instance_;
}  // namespace president
}  // namespace kakaIM
namespace kakaIM {
namespace president {

enum ResponseJoinClusterMessage_JoinResult {
  ResponseJoinClusterMessage_JoinResult_Success = 1,
  ResponseJoinClusterMessage_JoinResult_Failure = 2
};
bool ResponseJoinClusterMessage_JoinResult_IsValid(int value);
const ResponseJoinClusterMessage_JoinResult ResponseJoinClusterMessage_JoinResult_JoinResult_MIN = ResponseJoinClusterMessage_JoinResult_Success;
const ResponseJoinClusterMessage_JoinResult ResponseJoinClusterMessage_JoinResult_JoinResult_MAX = ResponseJoinClusterMessage_JoinResult_Failure;
const int ResponseJoinClusterMessage_JoinResult_JoinResult_ARRAYSIZE = ResponseJoinClusterMessage_JoinResult_JoinResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseJoinClusterMessage_JoinResult_descriptor();
inline const ::std::string& ResponseJoinClusterMessage_JoinResult_Name(ResponseJoinClusterMessage_JoinResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseJoinClusterMessage_JoinResult_descriptor(), value);
}
inline bool ResponseJoinClusterMessage_JoinResult_Parse(
    const ::std::string& name, ResponseJoinClusterMessage_JoinResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseJoinClusterMessage_JoinResult>(
    ResponseJoinClusterMessage_JoinResult_descriptor(), name, value);
}
enum UserOnlineStateMessage_OnlineState {
  UserOnlineStateMessage_OnlineState_Online = 1,
  UserOnlineStateMessage_OnlineState_Offline = 2,
  UserOnlineStateMessage_OnlineState_Invisible = 3
};
bool UserOnlineStateMessage_OnlineState_IsValid(int value);
const UserOnlineStateMessage_OnlineState UserOnlineStateMessage_OnlineState_OnlineState_MIN = UserOnlineStateMessage_OnlineState_Online;
const UserOnlineStateMessage_OnlineState UserOnlineStateMessage_OnlineState_OnlineState_MAX = UserOnlineStateMessage_OnlineState_Invisible;
const int UserOnlineStateMessage_OnlineState_OnlineState_ARRAYSIZE = UserOnlineStateMessage_OnlineState_OnlineState_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserOnlineStateMessage_OnlineState_descriptor();
inline const ::std::string& UserOnlineStateMessage_OnlineState_Name(UserOnlineStateMessage_OnlineState value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserOnlineStateMessage_OnlineState_descriptor(), value);
}
inline bool UserOnlineStateMessage_OnlineState_Parse(
    const ::std::string& name, UserOnlineStateMessage_OnlineState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserOnlineStateMessage_OnlineState>(
    UserOnlineStateMessage_OnlineState_descriptor(), name, value);
}
// ===================================================================

class RequestJoinClusterMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.RequestJoinClusterMessage) */ {
 public:
  RequestJoinClusterMessage();
  virtual ~RequestJoinClusterMessage();

  RequestJoinClusterMessage(const RequestJoinClusterMessage& from);

  inline RequestJoinClusterMessage& operator=(const RequestJoinClusterMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestJoinClusterMessage(RequestJoinClusterMessage&& from) noexcept
    : RequestJoinClusterMessage() {
    *this = ::std::move(from);
  }

  inline RequestJoinClusterMessage& operator=(RequestJoinClusterMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestJoinClusterMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestJoinClusterMessage* internal_default_instance() {
    return reinterpret_cast<const RequestJoinClusterMessage*>(
               &_RequestJoinClusterMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RequestJoinClusterMessage* other);
  friend void swap(RequestJoinClusterMessage& a, RequestJoinClusterMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestJoinClusterMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestJoinClusterMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestJoinClusterMessage& from);
  void MergeFrom(const RequestJoinClusterMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestJoinClusterMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string serverID = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // required string invitationCode = 2;
  bool has_invitationcode() const;
  void clear_invitationcode();
  static const int kInvitationCodeFieldNumber = 2;
  const ::std::string& invitationcode() const;
  void set_invitationcode(const ::std::string& value);
  #if LANG_CXX11
  void set_invitationcode(::std::string&& value);
  #endif
  void set_invitationcode(const char* value);
  void set_invitationcode(const char* value, size_t size);
  ::std::string* mutable_invitationcode();
  ::std::string* release_invitationcode();
  void set_allocated_invitationcode(::std::string* invitationcode);

  // required string serviceAddr = 5;
  bool has_serviceaddr() const;
  void clear_serviceaddr();
  static const int kServiceAddrFieldNumber = 5;
  const ::std::string& serviceaddr() const;
  void set_serviceaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_serviceaddr(::std::string&& value);
  #endif
  void set_serviceaddr(const char* value);
  void set_serviceaddr(const char* value, size_t size);
  ::std::string* mutable_serviceaddr();
  ::std::string* release_serviceaddr();
  void set_allocated_serviceaddr(::std::string* serviceaddr);

  // required float Longitude = 3;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 3;
  float longitude() const;
  void set_longitude(float value);

  // required float latitude = 4;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 4;
  float latitude() const;
  void set_latitude(float value);

  // required int32 servicePort = 6;
  bool has_serviceport() const;
  void clear_serviceport();
  static const int kServicePortFieldNumber = 6;
  ::google::protobuf::int32 serviceport() const;
  void set_serviceport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kakaIM.president.RequestJoinClusterMessage)
 private:
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_invitationcode();
  void clear_has_invitationcode();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_serviceaddr();
  void clear_has_serviceaddr();
  void set_has_serviceport();
  void clear_has_serviceport();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  ::google::protobuf::internal::ArenaStringPtr invitationcode_;
  ::google::protobuf::internal::ArenaStringPtr serviceaddr_;
  float longitude_;
  float latitude_;
  ::google::protobuf::int32 serviceport_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsRequestJoinClusterMessageImpl();
};
// -------------------------------------------------------------------

class ResponseJoinClusterMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.ResponseJoinClusterMessage) */ {
 public:
  ResponseJoinClusterMessage();
  virtual ~ResponseJoinClusterMessage();

  ResponseJoinClusterMessage(const ResponseJoinClusterMessage& from);

  inline ResponseJoinClusterMessage& operator=(const ResponseJoinClusterMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseJoinClusterMessage(ResponseJoinClusterMessage&& from) noexcept
    : ResponseJoinClusterMessage() {
    *this = ::std::move(from);
  }

  inline ResponseJoinClusterMessage& operator=(ResponseJoinClusterMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseJoinClusterMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseJoinClusterMessage* internal_default_instance() {
    return reinterpret_cast<const ResponseJoinClusterMessage*>(
               &_ResponseJoinClusterMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ResponseJoinClusterMessage* other);
  friend void swap(ResponseJoinClusterMessage& a, ResponseJoinClusterMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseJoinClusterMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseJoinClusterMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseJoinClusterMessage& from);
  void MergeFrom(const ResponseJoinClusterMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseJoinClusterMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ResponseJoinClusterMessage_JoinResult JoinResult;
  static const JoinResult Success =
    ResponseJoinClusterMessage_JoinResult_Success;
  static const JoinResult Failure =
    ResponseJoinClusterMessage_JoinResult_Failure;
  static inline bool JoinResult_IsValid(int value) {
    return ResponseJoinClusterMessage_JoinResult_IsValid(value);
  }
  static const JoinResult JoinResult_MIN =
    ResponseJoinClusterMessage_JoinResult_JoinResult_MIN;
  static const JoinResult JoinResult_MAX =
    ResponseJoinClusterMessage_JoinResult_JoinResult_MAX;
  static const int JoinResult_ARRAYSIZE =
    ResponseJoinClusterMessage_JoinResult_JoinResult_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinResult_descriptor() {
    return ResponseJoinClusterMessage_JoinResult_descriptor();
  }
  static inline const ::std::string& JoinResult_Name(JoinResult value) {
    return ResponseJoinClusterMessage_JoinResult_Name(value);
  }
  static inline bool JoinResult_Parse(const ::std::string& name,
      JoinResult* value) {
    return ResponseJoinClusterMessage_JoinResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .kakaIM.president.ResponseJoinClusterMessage.JoinResult result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::kakaIM::president::ResponseJoinClusterMessage_JoinResult result() const;
  void set_result(::kakaIM::president::ResponseJoinClusterMessage_JoinResult value);

  // @@protoc_insertion_point(class_scope:kakaIM.president.ResponseJoinClusterMessage)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int result_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsResponseJoinClusterMessageImpl();
};
// -------------------------------------------------------------------

class HeartBeatMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.HeartBeatMessage) */ {
 public:
  HeartBeatMessage();
  virtual ~HeartBeatMessage();

  HeartBeatMessage(const HeartBeatMessage& from);

  inline HeartBeatMessage& operator=(const HeartBeatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartBeatMessage(HeartBeatMessage&& from) noexcept
    : HeartBeatMessage() {
    *this = ::std::move(from);
  }

  inline HeartBeatMessage& operator=(HeartBeatMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartBeatMessage* internal_default_instance() {
    return reinterpret_cast<const HeartBeatMessage*>(
               &_HeartBeatMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(HeartBeatMessage* other);
  friend void swap(HeartBeatMessage& a, HeartBeatMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartBeatMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartBeatMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeartBeatMessage& from);
  void MergeFrom(const HeartBeatMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeartBeatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string serverID = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // required string timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::std::string& timestamp() const;
  void set_timestamp(const ::std::string& value);
  #if LANG_CXX11
  void set_timestamp(::std::string&& value);
  #endif
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  ::std::string* mutable_timestamp();
  ::std::string* release_timestamp();
  void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:kakaIM.president.HeartBeatMessage)
 private:
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  ::google::protobuf::internal::ArenaStringPtr timestamp_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsHeartBeatMessageImpl();
};
// -------------------------------------------------------------------

class ResponseHeartBeatMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.ResponseHeartBeatMessage) */ {
 public:
  ResponseHeartBeatMessage();
  virtual ~ResponseHeartBeatMessage();

  ResponseHeartBeatMessage(const ResponseHeartBeatMessage& from);

  inline ResponseHeartBeatMessage& operator=(const ResponseHeartBeatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseHeartBeatMessage(ResponseHeartBeatMessage&& from) noexcept
    : ResponseHeartBeatMessage() {
    *this = ::std::move(from);
  }

  inline ResponseHeartBeatMessage& operator=(ResponseHeartBeatMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeartBeatMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseHeartBeatMessage* internal_default_instance() {
    return reinterpret_cast<const ResponseHeartBeatMessage*>(
               &_ResponseHeartBeatMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ResponseHeartBeatMessage* other);
  friend void swap(ResponseHeartBeatMessage& a, ResponseHeartBeatMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseHeartBeatMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseHeartBeatMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseHeartBeatMessage& from);
  void MergeFrom(const ResponseHeartBeatMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseHeartBeatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::std::string& timestamp() const;
  void set_timestamp(const ::std::string& value);
  #if LANG_CXX11
  void set_timestamp(::std::string&& value);
  #endif
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  ::std::string* mutable_timestamp();
  ::std::string* release_timestamp();
  void set_allocated_timestamp(::std::string* timestamp);

  // @@protoc_insertion_point(class_scope:kakaIM.president.ResponseHeartBeatMessage)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr timestamp_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsResponseHeartBeatMessageImpl();
};
// -------------------------------------------------------------------

class NodeSecessionMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.NodeSecessionMessage) */ {
 public:
  NodeSecessionMessage();
  virtual ~NodeSecessionMessage();

  NodeSecessionMessage(const NodeSecessionMessage& from);

  inline NodeSecessionMessage& operator=(const NodeSecessionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeSecessionMessage(NodeSecessionMessage&& from) noexcept
    : NodeSecessionMessage() {
    *this = ::std::move(from);
  }

  inline NodeSecessionMessage& operator=(NodeSecessionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeSecessionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeSecessionMessage* internal_default_instance() {
    return reinterpret_cast<const NodeSecessionMessage*>(
               &_NodeSecessionMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(NodeSecessionMessage* other);
  friend void swap(NodeSecessionMessage& a, NodeSecessionMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeSecessionMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeSecessionMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeSecessionMessage& from);
  void MergeFrom(const NodeSecessionMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeSecessionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string serverID = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // @@protoc_insertion_point(class_scope:kakaIM.president.NodeSecessionMessage)
 private:
  void set_has_serverid();
  void clear_has_serverid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsNodeSecessionMessageImpl();
};
// -------------------------------------------------------------------

class UserOnlineStateMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.UserOnlineStateMessage) */ {
 public:
  UserOnlineStateMessage();
  virtual ~UserOnlineStateMessage();

  UserOnlineStateMessage(const UserOnlineStateMessage& from);

  inline UserOnlineStateMessage& operator=(const UserOnlineStateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserOnlineStateMessage(UserOnlineStateMessage&& from) noexcept
    : UserOnlineStateMessage() {
    *this = ::std::move(from);
  }

  inline UserOnlineStateMessage& operator=(UserOnlineStateMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOnlineStateMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserOnlineStateMessage* internal_default_instance() {
    return reinterpret_cast<const UserOnlineStateMessage*>(
               &_UserOnlineStateMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(UserOnlineStateMessage* other);
  friend void swap(UserOnlineStateMessage& a, UserOnlineStateMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserOnlineStateMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  UserOnlineStateMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserOnlineStateMessage& from);
  void MergeFrom(const UserOnlineStateMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserOnlineStateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserOnlineStateMessage_OnlineState OnlineState;
  static const OnlineState Online =
    UserOnlineStateMessage_OnlineState_Online;
  static const OnlineState Offline =
    UserOnlineStateMessage_OnlineState_Offline;
  static const OnlineState Invisible =
    UserOnlineStateMessage_OnlineState_Invisible;
  static inline bool OnlineState_IsValid(int value) {
    return UserOnlineStateMessage_OnlineState_IsValid(value);
  }
  static const OnlineState OnlineState_MIN =
    UserOnlineStateMessage_OnlineState_OnlineState_MIN;
  static const OnlineState OnlineState_MAX =
    UserOnlineStateMessage_OnlineState_OnlineState_MAX;
  static const int OnlineState_ARRAYSIZE =
    UserOnlineStateMessage_OnlineState_OnlineState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OnlineState_descriptor() {
    return UserOnlineStateMessage_OnlineState_descriptor();
  }
  static inline const ::std::string& OnlineState_Name(OnlineState value) {
    return UserOnlineStateMessage_OnlineState_Name(value);
  }
  static inline bool OnlineState_Parse(const ::std::string& name,
      OnlineState* value) {
    return UserOnlineStateMessage_OnlineState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string serverID = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // required string userAccount = 2;
  bool has_useraccount() const;
  void clear_useraccount();
  static const int kUserAccountFieldNumber = 2;
  const ::std::string& useraccount() const;
  void set_useraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_useraccount(::std::string&& value);
  #endif
  void set_useraccount(const char* value);
  void set_useraccount(const char* value, size_t size);
  ::std::string* mutable_useraccount();
  ::std::string* release_useraccount();
  void set_allocated_useraccount(::std::string* useraccount);

  // required .kakaIM.president.UserOnlineStateMessage.OnlineState userState = 3;
  bool has_userstate() const;
  void clear_userstate();
  static const int kUserStateFieldNumber = 3;
  ::kakaIM::president::UserOnlineStateMessage_OnlineState userstate() const;
  void set_userstate(::kakaIM::president::UserOnlineStateMessage_OnlineState value);

  // @@protoc_insertion_point(class_scope:kakaIM.president.UserOnlineStateMessage)
 private:
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_useraccount();
  void clear_has_useraccount();
  void set_has_userstate();
  void clear_has_userstate();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  ::google::protobuf::internal::ArenaStringPtr useraccount_;
  int userstate_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsUserOnlineStateMessageImpl();
};
// -------------------------------------------------------------------

class UpdateUserOnlineStateMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.UpdateUserOnlineStateMessage) */ {
 public:
  UpdateUserOnlineStateMessage();
  virtual ~UpdateUserOnlineStateMessage();

  UpdateUserOnlineStateMessage(const UpdateUserOnlineStateMessage& from);

  inline UpdateUserOnlineStateMessage& operator=(const UpdateUserOnlineStateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateUserOnlineStateMessage(UpdateUserOnlineStateMessage&& from) noexcept
    : UpdateUserOnlineStateMessage() {
    *this = ::std::move(from);
  }

  inline UpdateUserOnlineStateMessage& operator=(UpdateUserOnlineStateMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateUserOnlineStateMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateUserOnlineStateMessage* internal_default_instance() {
    return reinterpret_cast<const UpdateUserOnlineStateMessage*>(
               &_UpdateUserOnlineStateMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(UpdateUserOnlineStateMessage* other);
  friend void swap(UpdateUserOnlineStateMessage& a, UpdateUserOnlineStateMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateUserOnlineStateMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateUserOnlineStateMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateUserOnlineStateMessage& from);
  void MergeFrom(const UpdateUserOnlineStateMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateUserOnlineStateMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kakaIM.president.UserOnlineStateMessage userOnlineState = 1;
  int useronlinestate_size() const;
  void clear_useronlinestate();
  static const int kUserOnlineStateFieldNumber = 1;
  const ::kakaIM::president::UserOnlineStateMessage& useronlinestate(int index) const;
  ::kakaIM::president::UserOnlineStateMessage* mutable_useronlinestate(int index);
  ::kakaIM::president::UserOnlineStateMessage* add_useronlinestate();
  ::google::protobuf::RepeatedPtrField< ::kakaIM::president::UserOnlineStateMessage >*
      mutable_useronlinestate();
  const ::google::protobuf::RepeatedPtrField< ::kakaIM::president::UserOnlineStateMessage >&
      useronlinestate() const;

  // @@protoc_insertion_point(class_scope:kakaIM.president.UpdateUserOnlineStateMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kakaIM::president::UserOnlineStateMessage > useronlinestate_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsUpdateUserOnlineStateMessageImpl();
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.ServerMessage) */ {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ServerMessage* other);
  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string serverID = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // required string messageType = 2;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& messagetype() const;
  void set_messagetype(const ::std::string& value);
  #if LANG_CXX11
  void set_messagetype(::std::string&& value);
  #endif
  void set_messagetype(const char* value);
  void set_messagetype(const char* value, size_t size);
  ::std::string* mutable_messagetype();
  ::std::string* release_messagetype();
  void set_allocated_messagetype(::std::string* messagetype);

  // required bytes content = 3;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required string targetUser = 4;
  bool has_targetuser() const;
  void clear_targetuser();
  static const int kTargetUserFieldNumber = 4;
  const ::std::string& targetuser() const;
  void set_targetuser(const ::std::string& value);
  #if LANG_CXX11
  void set_targetuser(::std::string&& value);
  #endif
  void set_targetuser(const char* value);
  void set_targetuser(const char* value, size_t size);
  ::std::string* mutable_targetuser();
  ::std::string* release_targetuser();
  void set_allocated_targetuser(::std::string* targetuser);

  // @@protoc_insertion_point(class_scope:kakaIM.president.ServerMessage)
 private:
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_messagetype();
  void clear_has_messagetype();
  void set_has_content();
  void clear_has_content();
  void set_has_targetuser();
  void clear_has_targetuser();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  ::google::protobuf::internal::ArenaStringPtr messagetype_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr targetuser_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsServerMessageImpl();
};
// -------------------------------------------------------------------

class SessionMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.SessionMessage) */ {
 public:
  SessionMessage();
  virtual ~SessionMessage();

  SessionMessage(const SessionMessage& from);

  inline SessionMessage& operator=(const SessionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionMessage(SessionMessage&& from) noexcept
    : SessionMessage() {
    *this = ::std::move(from);
  }

  inline SessionMessage& operator=(SessionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionMessage* internal_default_instance() {
    return reinterpret_cast<const SessionMessage*>(
               &_SessionMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SessionMessage* other);
  friend void swap(SessionMessage& a, SessionMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SessionMessage& from);
  void MergeFrom(const SessionMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SessionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string serverID = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIDFieldNumber = 1;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // required string targetServerID = 2;
  bool has_targetserverid() const;
  void clear_targetserverid();
  static const int kTargetServerIDFieldNumber = 2;
  const ::std::string& targetserverid() const;
  void set_targetserverid(const ::std::string& value);
  #if LANG_CXX11
  void set_targetserverid(::std::string&& value);
  #endif
  void set_targetserverid(const char* value);
  void set_targetserverid(const char* value, size_t size);
  ::std::string* mutable_targetserverid();
  ::std::string* release_targetserverid();
  void set_allocated_targetserverid(::std::string* targetserverid);

  // required string targetSessionID = 3;
  bool has_targetsessionid() const;
  void clear_targetsessionid();
  static const int kTargetSessionIDFieldNumber = 3;
  const ::std::string& targetsessionid() const;
  void set_targetsessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_targetsessionid(::std::string&& value);
  #endif
  void set_targetsessionid(const char* value);
  void set_targetsessionid(const char* value, size_t size);
  ::std::string* mutable_targetsessionid();
  ::std::string* release_targetsessionid();
  void set_allocated_targetsessionid(::std::string* targetsessionid);

  // required string messageType = 4;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 4;
  const ::std::string& messagetype() const;
  void set_messagetype(const ::std::string& value);
  #if LANG_CXX11
  void set_messagetype(::std::string&& value);
  #endif
  void set_messagetype(const char* value);
  void set_messagetype(const char* value, size_t size);
  ::std::string* mutable_messagetype();
  ::std::string* release_messagetype();
  void set_allocated_messagetype(::std::string* messagetype);

  // required bytes content = 5;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 5;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:kakaIM.president.SessionMessage)
 private:
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_targetserverid();
  void clear_has_targetserverid();
  void set_has_targetsessionid();
  void clear_has_targetsessionid();
  void set_has_messagetype();
  void clear_has_messagetype();
  void set_has_content();
  void clear_has_content();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  ::google::protobuf::internal::ArenaStringPtr targetserverid_;
  ::google::protobuf::internal::ArenaStringPtr targetsessionid_;
  ::google::protobuf::internal::ArenaStringPtr messagetype_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsSessionMessageImpl();
};
// -------------------------------------------------------------------

class RequestMessageIDMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.RequestMessageIDMessage) */ {
 public:
  RequestMessageIDMessage();
  virtual ~RequestMessageIDMessage();

  RequestMessageIDMessage(const RequestMessageIDMessage& from);

  inline RequestMessageIDMessage& operator=(const RequestMessageIDMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestMessageIDMessage(RequestMessageIDMessage&& from) noexcept
    : RequestMessageIDMessage() {
    *this = ::std::move(from);
  }

  inline RequestMessageIDMessage& operator=(RequestMessageIDMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMessageIDMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestMessageIDMessage* internal_default_instance() {
    return reinterpret_cast<const RequestMessageIDMessage*>(
               &_RequestMessageIDMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RequestMessageIDMessage* other);
  friend void swap(RequestMessageIDMessage& a, RequestMessageIDMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestMessageIDMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestMessageIDMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestMessageIDMessage& from);
  void MergeFrom(const RequestMessageIDMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestMessageIDMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userAccount = 1;
  bool has_useraccount() const;
  void clear_useraccount();
  static const int kUserAccountFieldNumber = 1;
  const ::std::string& useraccount() const;
  void set_useraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_useraccount(::std::string&& value);
  #endif
  void set_useraccount(const char* value);
  void set_useraccount(const char* value, size_t size);
  ::std::string* mutable_useraccount();
  ::std::string* release_useraccount();
  void set_allocated_useraccount(::std::string* useraccount);

  // required string serverID = 2;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIDFieldNumber = 2;
  const ::std::string& serverid() const;
  void set_serverid(const ::std::string& value);
  #if LANG_CXX11
  void set_serverid(::std::string&& value);
  #endif
  void set_serverid(const char* value);
  void set_serverid(const char* value, size_t size);
  ::std::string* mutable_serverid();
  ::std::string* release_serverid();
  void set_allocated_serverid(::std::string* serverid);

  // required bytes requestID = 3;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 3;
  const ::std::string& requestid() const;
  void set_requestid(const ::std::string& value);
  #if LANG_CXX11
  void set_requestid(::std::string&& value);
  #endif
  void set_requestid(const char* value);
  void set_requestid(const void* value, size_t size);
  ::std::string* mutable_requestid();
  ::std::string* release_requestid();
  void set_allocated_requestid(::std::string* requestid);

  // @@protoc_insertion_point(class_scope:kakaIM.president.RequestMessageIDMessage)
 private:
  void set_has_useraccount();
  void clear_has_useraccount();
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_requestid();
  void clear_has_requestid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr useraccount_;
  ::google::protobuf::internal::ArenaStringPtr serverid_;
  ::google::protobuf::internal::ArenaStringPtr requestid_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsRequestMessageIDMessageImpl();
};
// -------------------------------------------------------------------

class ResponseMessageIDMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.ResponseMessageIDMessage) */ {
 public:
  ResponseMessageIDMessage();
  virtual ~ResponseMessageIDMessage();

  ResponseMessageIDMessage(const ResponseMessageIDMessage& from);

  inline ResponseMessageIDMessage& operator=(const ResponseMessageIDMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseMessageIDMessage(ResponseMessageIDMessage&& from) noexcept
    : ResponseMessageIDMessage() {
    *this = ::std::move(from);
  }

  inline ResponseMessageIDMessage& operator=(ResponseMessageIDMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseMessageIDMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseMessageIDMessage* internal_default_instance() {
    return reinterpret_cast<const ResponseMessageIDMessage*>(
               &_ResponseMessageIDMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ResponseMessageIDMessage* other);
  friend void swap(ResponseMessageIDMessage& a, ResponseMessageIDMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseMessageIDMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseMessageIDMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseMessageIDMessage& from);
  void MergeFrom(const ResponseMessageIDMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseMessageIDMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userAccount = 1;
  bool has_useraccount() const;
  void clear_useraccount();
  static const int kUserAccountFieldNumber = 1;
  const ::std::string& useraccount() const;
  void set_useraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_useraccount(::std::string&& value);
  #endif
  void set_useraccount(const char* value);
  void set_useraccount(const char* value, size_t size);
  ::std::string* mutable_useraccount();
  ::std::string* release_useraccount();
  void set_allocated_useraccount(::std::string* useraccount);

  // required bytes requestID = 3;
  bool has_requestid() const;
  void clear_requestid();
  static const int kRequestIDFieldNumber = 3;
  const ::std::string& requestid() const;
  void set_requestid(const ::std::string& value);
  #if LANG_CXX11
  void set_requestid(::std::string&& value);
  #endif
  void set_requestid(const char* value);
  void set_requestid(const void* value, size_t size);
  ::std::string* mutable_requestid();
  ::std::string* release_requestid();
  void set_allocated_requestid(::std::string* requestid);

  // required uint64 messageID = 2;
  bool has_messageid() const;
  void clear_messageid();
  static const int kMessageIDFieldNumber = 2;
  ::google::protobuf::uint64 messageid() const;
  void set_messageid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kakaIM.president.ResponseMessageIDMessage)
 private:
  void set_has_useraccount();
  void clear_has_useraccount();
  void set_has_messageid();
  void clear_has_messageid();
  void set_has_requestid();
  void clear_has_requestid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr useraccount_;
  ::google::protobuf::internal::ArenaStringPtr requestid_;
  ::google::protobuf::uint64 messageid_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsResponseMessageIDMessageImpl();
};
// -------------------------------------------------------------------

class NodeLoadInfoMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kakaIM.president.NodeLoadInfoMessage) */ {
 public:
  NodeLoadInfoMessage();
  virtual ~NodeLoadInfoMessage();

  NodeLoadInfoMessage(const NodeLoadInfoMessage& from);

  inline NodeLoadInfoMessage& operator=(const NodeLoadInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeLoadInfoMessage(NodeLoadInfoMessage&& from) noexcept
    : NodeLoadInfoMessage() {
    *this = ::std::move(from);
  }

  inline NodeLoadInfoMessage& operator=(NodeLoadInfoMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeLoadInfoMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeLoadInfoMessage* internal_default_instance() {
    return reinterpret_cast<const NodeLoadInfoMessage*>(
               &_NodeLoadInfoMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(NodeLoadInfoMessage* other);
  friend void swap(NodeLoadInfoMessage& a, NodeLoadInfoMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeLoadInfoMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeLoadInfoMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NodeLoadInfoMessage& from);
  void MergeFrom(const NodeLoadInfoMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NodeLoadInfoMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 connectionCount = 1;
  bool has_connectioncount() const;
  void clear_connectioncount();
  static const int kConnectionCountFieldNumber = 1;
  ::google::protobuf::uint64 connectioncount() const;
  void set_connectioncount(::google::protobuf::uint64 value);

  // required float cpuUsage = 2;
  bool has_cpuusage() const;
  void clear_cpuusage();
  static const int kCpuUsageFieldNumber = 2;
  float cpuusage() const;
  void set_cpuusage(float value);

  // required float memUsage = 3;
  bool has_memusage() const;
  void clear_memusage();
  static const int kMemUsageFieldNumber = 3;
  float memusage() const;
  void set_memusage(float value);

  // @@protoc_insertion_point(class_scope:kakaIM.president.NodeLoadInfoMessage)
 private:
  void set_has_connectioncount();
  void clear_has_connectioncount();
  void set_has_cpuusage();
  void clear_has_cpuusage();
  void set_has_memusage();
  void clear_has_memusage();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 connectioncount_;
  float cpuusage_;
  float memusage_;
  friend struct ::protobuf_MessageCluster_2eproto::TableStruct;
  friend void ::protobuf_MessageCluster_2eproto::InitDefaultsNodeLoadInfoMessageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestJoinClusterMessage

// required string serverID = 1;
inline bool RequestJoinClusterMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestJoinClusterMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestJoinClusterMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestJoinClusterMessage::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& RequestJoinClusterMessage::serverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestJoinClusterMessage.serverID)
  return serverid_.GetNoArena();
}
inline void RequestJoinClusterMessage::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestJoinClusterMessage.serverID)
}
#if LANG_CXX11
inline void RequestJoinClusterMessage::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.RequestJoinClusterMessage.serverID)
}
#endif
inline void RequestJoinClusterMessage::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.RequestJoinClusterMessage.serverID)
}
inline void RequestJoinClusterMessage::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.RequestJoinClusterMessage.serverID)
}
inline ::std::string* RequestJoinClusterMessage::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.RequestJoinClusterMessage.serverID)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestJoinClusterMessage::release_serverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.RequestJoinClusterMessage.serverID)
  clear_has_serverid();
  return serverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestJoinClusterMessage::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.RequestJoinClusterMessage.serverID)
}

// required string invitationCode = 2;
inline bool RequestJoinClusterMessage::has_invitationcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestJoinClusterMessage::set_has_invitationcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestJoinClusterMessage::clear_has_invitationcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestJoinClusterMessage::clear_invitationcode() {
  invitationcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_invitationcode();
}
inline const ::std::string& RequestJoinClusterMessage::invitationcode() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestJoinClusterMessage.invitationCode)
  return invitationcode_.GetNoArena();
}
inline void RequestJoinClusterMessage::set_invitationcode(const ::std::string& value) {
  set_has_invitationcode();
  invitationcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestJoinClusterMessage.invitationCode)
}
#if LANG_CXX11
inline void RequestJoinClusterMessage::set_invitationcode(::std::string&& value) {
  set_has_invitationcode();
  invitationcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.RequestJoinClusterMessage.invitationCode)
}
#endif
inline void RequestJoinClusterMessage::set_invitationcode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_invitationcode();
  invitationcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.RequestJoinClusterMessage.invitationCode)
}
inline void RequestJoinClusterMessage::set_invitationcode(const char* value, size_t size) {
  set_has_invitationcode();
  invitationcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.RequestJoinClusterMessage.invitationCode)
}
inline ::std::string* RequestJoinClusterMessage::mutable_invitationcode() {
  set_has_invitationcode();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.RequestJoinClusterMessage.invitationCode)
  return invitationcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestJoinClusterMessage::release_invitationcode() {
  // @@protoc_insertion_point(field_release:kakaIM.president.RequestJoinClusterMessage.invitationCode)
  clear_has_invitationcode();
  return invitationcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestJoinClusterMessage::set_allocated_invitationcode(::std::string* invitationcode) {
  if (invitationcode != NULL) {
    set_has_invitationcode();
  } else {
    clear_has_invitationcode();
  }
  invitationcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), invitationcode);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.RequestJoinClusterMessage.invitationCode)
}

// required float Longitude = 3;
inline bool RequestJoinClusterMessage::has_longitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestJoinClusterMessage::set_has_longitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestJoinClusterMessage::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestJoinClusterMessage::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float RequestJoinClusterMessage::longitude() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestJoinClusterMessage.Longitude)
  return longitude_;
}
inline void RequestJoinClusterMessage::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestJoinClusterMessage.Longitude)
}

// required float latitude = 4;
inline bool RequestJoinClusterMessage::has_latitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestJoinClusterMessage::set_has_latitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestJoinClusterMessage::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestJoinClusterMessage::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float RequestJoinClusterMessage::latitude() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestJoinClusterMessage.latitude)
  return latitude_;
}
inline void RequestJoinClusterMessage::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestJoinClusterMessage.latitude)
}

// required string serviceAddr = 5;
inline bool RequestJoinClusterMessage::has_serviceaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestJoinClusterMessage::set_has_serviceaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestJoinClusterMessage::clear_has_serviceaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestJoinClusterMessage::clear_serviceaddr() {
  serviceaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serviceaddr();
}
inline const ::std::string& RequestJoinClusterMessage::serviceaddr() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
  return serviceaddr_.GetNoArena();
}
inline void RequestJoinClusterMessage::set_serviceaddr(const ::std::string& value) {
  set_has_serviceaddr();
  serviceaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
}
#if LANG_CXX11
inline void RequestJoinClusterMessage::set_serviceaddr(::std::string&& value) {
  set_has_serviceaddr();
  serviceaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
}
#endif
inline void RequestJoinClusterMessage::set_serviceaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serviceaddr();
  serviceaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
}
inline void RequestJoinClusterMessage::set_serviceaddr(const char* value, size_t size) {
  set_has_serviceaddr();
  serviceaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
}
inline ::std::string* RequestJoinClusterMessage::mutable_serviceaddr() {
  set_has_serviceaddr();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
  return serviceaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestJoinClusterMessage::release_serviceaddr() {
  // @@protoc_insertion_point(field_release:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
  clear_has_serviceaddr();
  return serviceaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestJoinClusterMessage::set_allocated_serviceaddr(::std::string* serviceaddr) {
  if (serviceaddr != NULL) {
    set_has_serviceaddr();
  } else {
    clear_has_serviceaddr();
  }
  serviceaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serviceaddr);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.RequestJoinClusterMessage.serviceAddr)
}

// required int32 servicePort = 6;
inline bool RequestJoinClusterMessage::has_serviceport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestJoinClusterMessage::set_has_serviceport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestJoinClusterMessage::clear_has_serviceport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestJoinClusterMessage::clear_serviceport() {
  serviceport_ = 0;
  clear_has_serviceport();
}
inline ::google::protobuf::int32 RequestJoinClusterMessage::serviceport() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestJoinClusterMessage.servicePort)
  return serviceport_;
}
inline void RequestJoinClusterMessage::set_serviceport(::google::protobuf::int32 value) {
  set_has_serviceport();
  serviceport_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestJoinClusterMessage.servicePort)
}

// -------------------------------------------------------------------

// ResponseJoinClusterMessage

// required .kakaIM.president.ResponseJoinClusterMessage.JoinResult result = 1;
inline bool ResponseJoinClusterMessage::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseJoinClusterMessage::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseJoinClusterMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseJoinClusterMessage::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::kakaIM::president::ResponseJoinClusterMessage_JoinResult ResponseJoinClusterMessage::result() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ResponseJoinClusterMessage.result)
  return static_cast< ::kakaIM::president::ResponseJoinClusterMessage_JoinResult >(result_);
}
inline void ResponseJoinClusterMessage::set_result(::kakaIM::president::ResponseJoinClusterMessage_JoinResult value) {
  assert(::kakaIM::president::ResponseJoinClusterMessage_JoinResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.ResponseJoinClusterMessage.result)
}

// -------------------------------------------------------------------

// HeartBeatMessage

// required string serverID = 1;
inline bool HeartBeatMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeatMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeatMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeatMessage::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& HeartBeatMessage::serverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.HeartBeatMessage.serverID)
  return serverid_.GetNoArena();
}
inline void HeartBeatMessage::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.HeartBeatMessage.serverID)
}
#if LANG_CXX11
inline void HeartBeatMessage::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.HeartBeatMessage.serverID)
}
#endif
inline void HeartBeatMessage::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.HeartBeatMessage.serverID)
}
inline void HeartBeatMessage::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.HeartBeatMessage.serverID)
}
inline ::std::string* HeartBeatMessage::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.HeartBeatMessage.serverID)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartBeatMessage::release_serverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.HeartBeatMessage.serverID)
  clear_has_serverid();
  return serverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartBeatMessage::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.HeartBeatMessage.serverID)
}

// required string timestamp = 2;
inline bool HeartBeatMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartBeatMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartBeatMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartBeatMessage::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timestamp();
}
inline const ::std::string& HeartBeatMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.HeartBeatMessage.timestamp)
  return timestamp_.GetNoArena();
}
inline void HeartBeatMessage::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.HeartBeatMessage.timestamp)
}
#if LANG_CXX11
inline void HeartBeatMessage::set_timestamp(::std::string&& value) {
  set_has_timestamp();
  timestamp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.HeartBeatMessage.timestamp)
}
#endif
inline void HeartBeatMessage::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.HeartBeatMessage.timestamp)
}
inline void HeartBeatMessage::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.HeartBeatMessage.timestamp)
}
inline ::std::string* HeartBeatMessage::mutable_timestamp() {
  set_has_timestamp();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.HeartBeatMessage.timestamp)
  return timestamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartBeatMessage::release_timestamp() {
  // @@protoc_insertion_point(field_release:kakaIM.president.HeartBeatMessage.timestamp)
  clear_has_timestamp();
  return timestamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartBeatMessage::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp != NULL) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  timestamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.HeartBeatMessage.timestamp)
}

// -------------------------------------------------------------------

// ResponseHeartBeatMessage

// required string timestamp = 2;
inline bool ResponseHeartBeatMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseHeartBeatMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseHeartBeatMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseHeartBeatMessage::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timestamp();
}
inline const ::std::string& ResponseHeartBeatMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ResponseHeartBeatMessage.timestamp)
  return timestamp_.GetNoArena();
}
inline void ResponseHeartBeatMessage::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.ResponseHeartBeatMessage.timestamp)
}
#if LANG_CXX11
inline void ResponseHeartBeatMessage::set_timestamp(::std::string&& value) {
  set_has_timestamp();
  timestamp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.ResponseHeartBeatMessage.timestamp)
}
#endif
inline void ResponseHeartBeatMessage::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.ResponseHeartBeatMessage.timestamp)
}
inline void ResponseHeartBeatMessage::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.ResponseHeartBeatMessage.timestamp)
}
inline ::std::string* ResponseHeartBeatMessage::mutable_timestamp() {
  set_has_timestamp();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.ResponseHeartBeatMessage.timestamp)
  return timestamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseHeartBeatMessage::release_timestamp() {
  // @@protoc_insertion_point(field_release:kakaIM.president.ResponseHeartBeatMessage.timestamp)
  clear_has_timestamp();
  return timestamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseHeartBeatMessage::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp != NULL) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  timestamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.ResponseHeartBeatMessage.timestamp)
}

// -------------------------------------------------------------------

// NodeSecessionMessage

// required string serverID = 1;
inline bool NodeSecessionMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeSecessionMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeSecessionMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeSecessionMessage::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& NodeSecessionMessage::serverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.NodeSecessionMessage.serverID)
  return serverid_.GetNoArena();
}
inline void NodeSecessionMessage::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.NodeSecessionMessage.serverID)
}
#if LANG_CXX11
inline void NodeSecessionMessage::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.NodeSecessionMessage.serverID)
}
#endif
inline void NodeSecessionMessage::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.NodeSecessionMessage.serverID)
}
inline void NodeSecessionMessage::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.NodeSecessionMessage.serverID)
}
inline ::std::string* NodeSecessionMessage::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.NodeSecessionMessage.serverID)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeSecessionMessage::release_serverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.NodeSecessionMessage.serverID)
  clear_has_serverid();
  return serverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeSecessionMessage::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.NodeSecessionMessage.serverID)
}

// -------------------------------------------------------------------

// UserOnlineStateMessage

// required string serverID = 1;
inline bool UserOnlineStateMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOnlineStateMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOnlineStateMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOnlineStateMessage::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& UserOnlineStateMessage::serverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.UserOnlineStateMessage.serverID)
  return serverid_.GetNoArena();
}
inline void UserOnlineStateMessage::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.UserOnlineStateMessage.serverID)
}
#if LANG_CXX11
inline void UserOnlineStateMessage::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.UserOnlineStateMessage.serverID)
}
#endif
inline void UserOnlineStateMessage::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.UserOnlineStateMessage.serverID)
}
inline void UserOnlineStateMessage::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.UserOnlineStateMessage.serverID)
}
inline ::std::string* UserOnlineStateMessage::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.UserOnlineStateMessage.serverID)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserOnlineStateMessage::release_serverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.UserOnlineStateMessage.serverID)
  clear_has_serverid();
  return serverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserOnlineStateMessage::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.UserOnlineStateMessage.serverID)
}

// required string userAccount = 2;
inline bool UserOnlineStateMessage::has_useraccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOnlineStateMessage::set_has_useraccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOnlineStateMessage::clear_has_useraccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOnlineStateMessage::clear_useraccount() {
  useraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_useraccount();
}
inline const ::std::string& UserOnlineStateMessage::useraccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.UserOnlineStateMessage.userAccount)
  return useraccount_.GetNoArena();
}
inline void UserOnlineStateMessage::set_useraccount(const ::std::string& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.UserOnlineStateMessage.userAccount)
}
#if LANG_CXX11
inline void UserOnlineStateMessage::set_useraccount(::std::string&& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.UserOnlineStateMessage.userAccount)
}
#endif
inline void UserOnlineStateMessage::set_useraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.UserOnlineStateMessage.userAccount)
}
inline void UserOnlineStateMessage::set_useraccount(const char* value, size_t size) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.UserOnlineStateMessage.userAccount)
}
inline ::std::string* UserOnlineStateMessage::mutable_useraccount() {
  set_has_useraccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.UserOnlineStateMessage.userAccount)
  return useraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserOnlineStateMessage::release_useraccount() {
  // @@protoc_insertion_point(field_release:kakaIM.president.UserOnlineStateMessage.userAccount)
  clear_has_useraccount();
  return useraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserOnlineStateMessage::set_allocated_useraccount(::std::string* useraccount) {
  if (useraccount != NULL) {
    set_has_useraccount();
  } else {
    clear_has_useraccount();
  }
  useraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), useraccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.UserOnlineStateMessage.userAccount)
}

// required .kakaIM.president.UserOnlineStateMessage.OnlineState userState = 3;
inline bool UserOnlineStateMessage::has_userstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserOnlineStateMessage::set_has_userstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserOnlineStateMessage::clear_has_userstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserOnlineStateMessage::clear_userstate() {
  userstate_ = 1;
  clear_has_userstate();
}
inline ::kakaIM::president::UserOnlineStateMessage_OnlineState UserOnlineStateMessage::userstate() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.UserOnlineStateMessage.userState)
  return static_cast< ::kakaIM::president::UserOnlineStateMessage_OnlineState >(userstate_);
}
inline void UserOnlineStateMessage::set_userstate(::kakaIM::president::UserOnlineStateMessage_OnlineState value) {
  assert(::kakaIM::president::UserOnlineStateMessage_OnlineState_IsValid(value));
  set_has_userstate();
  userstate_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.UserOnlineStateMessage.userState)
}

// -------------------------------------------------------------------

// UpdateUserOnlineStateMessage

// repeated .kakaIM.president.UserOnlineStateMessage userOnlineState = 1;
inline int UpdateUserOnlineStateMessage::useronlinestate_size() const {
  return useronlinestate_.size();
}
inline void UpdateUserOnlineStateMessage::clear_useronlinestate() {
  useronlinestate_.Clear();
}
inline const ::kakaIM::president::UserOnlineStateMessage& UpdateUserOnlineStateMessage::useronlinestate(int index) const {
  // @@protoc_insertion_point(field_get:kakaIM.president.UpdateUserOnlineStateMessage.userOnlineState)
  return useronlinestate_.Get(index);
}
inline ::kakaIM::president::UserOnlineStateMessage* UpdateUserOnlineStateMessage::mutable_useronlinestate(int index) {
  // @@protoc_insertion_point(field_mutable:kakaIM.president.UpdateUserOnlineStateMessage.userOnlineState)
  return useronlinestate_.Mutable(index);
}
inline ::kakaIM::president::UserOnlineStateMessage* UpdateUserOnlineStateMessage::add_useronlinestate() {
  // @@protoc_insertion_point(field_add:kakaIM.president.UpdateUserOnlineStateMessage.userOnlineState)
  return useronlinestate_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::kakaIM::president::UserOnlineStateMessage >*
UpdateUserOnlineStateMessage::mutable_useronlinestate() {
  // @@protoc_insertion_point(field_mutable_list:kakaIM.president.UpdateUserOnlineStateMessage.userOnlineState)
  return &useronlinestate_;
}
inline const ::google::protobuf::RepeatedPtrField< ::kakaIM::president::UserOnlineStateMessage >&
UpdateUserOnlineStateMessage::useronlinestate() const {
  // @@protoc_insertion_point(field_list:kakaIM.president.UpdateUserOnlineStateMessage.userOnlineState)
  return useronlinestate_;
}

// -------------------------------------------------------------------

// ServerMessage

// required string serverID = 1;
inline bool ServerMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& ServerMessage::serverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ServerMessage.serverID)
  return serverid_.GetNoArena();
}
inline void ServerMessage::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.ServerMessage.serverID)
}
#if LANG_CXX11
inline void ServerMessage::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.ServerMessage.serverID)
}
#endif
inline void ServerMessage::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.ServerMessage.serverID)
}
inline void ServerMessage::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.ServerMessage.serverID)
}
inline ::std::string* ServerMessage::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.ServerMessage.serverID)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMessage::release_serverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.ServerMessage.serverID)
  clear_has_serverid();
  return serverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMessage::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.ServerMessage.serverID)
}

// required string messageType = 2;
inline bool ServerMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMessage::clear_messagetype() {
  messagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagetype();
}
inline const ::std::string& ServerMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ServerMessage.messageType)
  return messagetype_.GetNoArena();
}
inline void ServerMessage::set_messagetype(const ::std::string& value) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.ServerMessage.messageType)
}
#if LANG_CXX11
inline void ServerMessage::set_messagetype(::std::string&& value) {
  set_has_messagetype();
  messagetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.ServerMessage.messageType)
}
#endif
inline void ServerMessage::set_messagetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.ServerMessage.messageType)
}
inline void ServerMessage::set_messagetype(const char* value, size_t size) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.ServerMessage.messageType)
}
inline ::std::string* ServerMessage::mutable_messagetype() {
  set_has_messagetype();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.ServerMessage.messageType)
  return messagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMessage::release_messagetype() {
  // @@protoc_insertion_point(field_release:kakaIM.president.ServerMessage.messageType)
  clear_has_messagetype();
  return messagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMessage::set_allocated_messagetype(::std::string* messagetype) {
  if (messagetype != NULL) {
    set_has_messagetype();
  } else {
    clear_has_messagetype();
  }
  messagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagetype);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.ServerMessage.messageType)
}

// required bytes content = 3;
inline bool ServerMessage::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMessage::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMessage::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMessage::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& ServerMessage::content() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ServerMessage.content)
  return content_.GetNoArena();
}
inline void ServerMessage::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.ServerMessage.content)
}
#if LANG_CXX11
inline void ServerMessage::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.ServerMessage.content)
}
#endif
inline void ServerMessage::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.ServerMessage.content)
}
inline void ServerMessage::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.ServerMessage.content)
}
inline ::std::string* ServerMessage::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.ServerMessage.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMessage::release_content() {
  // @@protoc_insertion_point(field_release:kakaIM.president.ServerMessage.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMessage::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.ServerMessage.content)
}

// required string targetUser = 4;
inline bool ServerMessage::has_targetuser() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerMessage::set_has_targetuser() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerMessage::clear_has_targetuser() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerMessage::clear_targetuser() {
  targetuser_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_targetuser();
}
inline const ::std::string& ServerMessage::targetuser() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ServerMessage.targetUser)
  return targetuser_.GetNoArena();
}
inline void ServerMessage::set_targetuser(const ::std::string& value) {
  set_has_targetuser();
  targetuser_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.ServerMessage.targetUser)
}
#if LANG_CXX11
inline void ServerMessage::set_targetuser(::std::string&& value) {
  set_has_targetuser();
  targetuser_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.ServerMessage.targetUser)
}
#endif
inline void ServerMessage::set_targetuser(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_targetuser();
  targetuser_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.ServerMessage.targetUser)
}
inline void ServerMessage::set_targetuser(const char* value, size_t size) {
  set_has_targetuser();
  targetuser_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.ServerMessage.targetUser)
}
inline ::std::string* ServerMessage::mutable_targetuser() {
  set_has_targetuser();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.ServerMessage.targetUser)
  return targetuser_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerMessage::release_targetuser() {
  // @@protoc_insertion_point(field_release:kakaIM.president.ServerMessage.targetUser)
  clear_has_targetuser();
  return targetuser_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerMessage::set_allocated_targetuser(::std::string* targetuser) {
  if (targetuser != NULL) {
    set_has_targetuser();
  } else {
    clear_has_targetuser();
  }
  targetuser_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetuser);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.ServerMessage.targetUser)
}

// -------------------------------------------------------------------

// SessionMessage

// required string serverID = 1;
inline bool SessionMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionMessage::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& SessionMessage::serverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.SessionMessage.serverID)
  return serverid_.GetNoArena();
}
inline void SessionMessage::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.SessionMessage.serverID)
}
#if LANG_CXX11
inline void SessionMessage::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.SessionMessage.serverID)
}
#endif
inline void SessionMessage::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.SessionMessage.serverID)
}
inline void SessionMessage::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.SessionMessage.serverID)
}
inline ::std::string* SessionMessage::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.SessionMessage.serverID)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionMessage::release_serverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.SessionMessage.serverID)
  clear_has_serverid();
  return serverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionMessage::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.SessionMessage.serverID)
}

// required string targetServerID = 2;
inline bool SessionMessage::has_targetserverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionMessage::set_has_targetserverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionMessage::clear_has_targetserverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionMessage::clear_targetserverid() {
  targetserverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_targetserverid();
}
inline const ::std::string& SessionMessage::targetserverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.SessionMessage.targetServerID)
  return targetserverid_.GetNoArena();
}
inline void SessionMessage::set_targetserverid(const ::std::string& value) {
  set_has_targetserverid();
  targetserverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.SessionMessage.targetServerID)
}
#if LANG_CXX11
inline void SessionMessage::set_targetserverid(::std::string&& value) {
  set_has_targetserverid();
  targetserverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.SessionMessage.targetServerID)
}
#endif
inline void SessionMessage::set_targetserverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_targetserverid();
  targetserverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.SessionMessage.targetServerID)
}
inline void SessionMessage::set_targetserverid(const char* value, size_t size) {
  set_has_targetserverid();
  targetserverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.SessionMessage.targetServerID)
}
inline ::std::string* SessionMessage::mutable_targetserverid() {
  set_has_targetserverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.SessionMessage.targetServerID)
  return targetserverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionMessage::release_targetserverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.SessionMessage.targetServerID)
  clear_has_targetserverid();
  return targetserverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionMessage::set_allocated_targetserverid(::std::string* targetserverid) {
  if (targetserverid != NULL) {
    set_has_targetserverid();
  } else {
    clear_has_targetserverid();
  }
  targetserverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetserverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.SessionMessage.targetServerID)
}

// required string targetSessionID = 3;
inline bool SessionMessage::has_targetsessionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionMessage::set_has_targetsessionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionMessage::clear_has_targetsessionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionMessage::clear_targetsessionid() {
  targetsessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_targetsessionid();
}
inline const ::std::string& SessionMessage::targetsessionid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.SessionMessage.targetSessionID)
  return targetsessionid_.GetNoArena();
}
inline void SessionMessage::set_targetsessionid(const ::std::string& value) {
  set_has_targetsessionid();
  targetsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.SessionMessage.targetSessionID)
}
#if LANG_CXX11
inline void SessionMessage::set_targetsessionid(::std::string&& value) {
  set_has_targetsessionid();
  targetsessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.SessionMessage.targetSessionID)
}
#endif
inline void SessionMessage::set_targetsessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_targetsessionid();
  targetsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.SessionMessage.targetSessionID)
}
inline void SessionMessage::set_targetsessionid(const char* value, size_t size) {
  set_has_targetsessionid();
  targetsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.SessionMessage.targetSessionID)
}
inline ::std::string* SessionMessage::mutable_targetsessionid() {
  set_has_targetsessionid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.SessionMessage.targetSessionID)
  return targetsessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionMessage::release_targetsessionid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.SessionMessage.targetSessionID)
  clear_has_targetsessionid();
  return targetsessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionMessage::set_allocated_targetsessionid(::std::string* targetsessionid) {
  if (targetsessionid != NULL) {
    set_has_targetsessionid();
  } else {
    clear_has_targetsessionid();
  }
  targetsessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetsessionid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.SessionMessage.targetSessionID)
}

// required string messageType = 4;
inline bool SessionMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionMessage::clear_messagetype() {
  messagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagetype();
}
inline const ::std::string& SessionMessage::messagetype() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.SessionMessage.messageType)
  return messagetype_.GetNoArena();
}
inline void SessionMessage::set_messagetype(const ::std::string& value) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.SessionMessage.messageType)
}
#if LANG_CXX11
inline void SessionMessage::set_messagetype(::std::string&& value) {
  set_has_messagetype();
  messagetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.SessionMessage.messageType)
}
#endif
inline void SessionMessage::set_messagetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.SessionMessage.messageType)
}
inline void SessionMessage::set_messagetype(const char* value, size_t size) {
  set_has_messagetype();
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.SessionMessage.messageType)
}
inline ::std::string* SessionMessage::mutable_messagetype() {
  set_has_messagetype();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.SessionMessage.messageType)
  return messagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionMessage::release_messagetype() {
  // @@protoc_insertion_point(field_release:kakaIM.president.SessionMessage.messageType)
  clear_has_messagetype();
  return messagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionMessage::set_allocated_messagetype(::std::string* messagetype) {
  if (messagetype != NULL) {
    set_has_messagetype();
  } else {
    clear_has_messagetype();
  }
  messagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagetype);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.SessionMessage.messageType)
}

// required bytes content = 5;
inline bool SessionMessage::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionMessage::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionMessage::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionMessage::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& SessionMessage::content() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.SessionMessage.content)
  return content_.GetNoArena();
}
inline void SessionMessage::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.SessionMessage.content)
}
#if LANG_CXX11
inline void SessionMessage::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.SessionMessage.content)
}
#endif
inline void SessionMessage::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.SessionMessage.content)
}
inline void SessionMessage::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.SessionMessage.content)
}
inline ::std::string* SessionMessage::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.SessionMessage.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionMessage::release_content() {
  // @@protoc_insertion_point(field_release:kakaIM.president.SessionMessage.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionMessage::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.SessionMessage.content)
}

// -------------------------------------------------------------------

// RequestMessageIDMessage

// required string userAccount = 1;
inline bool RequestMessageIDMessage::has_useraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestMessageIDMessage::set_has_useraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestMessageIDMessage::clear_has_useraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestMessageIDMessage::clear_useraccount() {
  useraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_useraccount();
}
inline const ::std::string& RequestMessageIDMessage::useraccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestMessageIDMessage.userAccount)
  return useraccount_.GetNoArena();
}
inline void RequestMessageIDMessage::set_useraccount(const ::std::string& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestMessageIDMessage.userAccount)
}
#if LANG_CXX11
inline void RequestMessageIDMessage::set_useraccount(::std::string&& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.RequestMessageIDMessage.userAccount)
}
#endif
inline void RequestMessageIDMessage::set_useraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.RequestMessageIDMessage.userAccount)
}
inline void RequestMessageIDMessage::set_useraccount(const char* value, size_t size) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.RequestMessageIDMessage.userAccount)
}
inline ::std::string* RequestMessageIDMessage::mutable_useraccount() {
  set_has_useraccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.RequestMessageIDMessage.userAccount)
  return useraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestMessageIDMessage::release_useraccount() {
  // @@protoc_insertion_point(field_release:kakaIM.president.RequestMessageIDMessage.userAccount)
  clear_has_useraccount();
  return useraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestMessageIDMessage::set_allocated_useraccount(::std::string* useraccount) {
  if (useraccount != NULL) {
    set_has_useraccount();
  } else {
    clear_has_useraccount();
  }
  useraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), useraccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.RequestMessageIDMessage.userAccount)
}

// required string serverID = 2;
inline bool RequestMessageIDMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestMessageIDMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestMessageIDMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestMessageIDMessage::clear_serverid() {
  serverid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverid();
}
inline const ::std::string& RequestMessageIDMessage::serverid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestMessageIDMessage.serverID)
  return serverid_.GetNoArena();
}
inline void RequestMessageIDMessage::set_serverid(const ::std::string& value) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestMessageIDMessage.serverID)
}
#if LANG_CXX11
inline void RequestMessageIDMessage::set_serverid(::std::string&& value) {
  set_has_serverid();
  serverid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.RequestMessageIDMessage.serverID)
}
#endif
inline void RequestMessageIDMessage::set_serverid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.RequestMessageIDMessage.serverID)
}
inline void RequestMessageIDMessage::set_serverid(const char* value, size_t size) {
  set_has_serverid();
  serverid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.RequestMessageIDMessage.serverID)
}
inline ::std::string* RequestMessageIDMessage::mutable_serverid() {
  set_has_serverid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.RequestMessageIDMessage.serverID)
  return serverid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestMessageIDMessage::release_serverid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.RequestMessageIDMessage.serverID)
  clear_has_serverid();
  return serverid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestMessageIDMessage::set_allocated_serverid(::std::string* serverid) {
  if (serverid != NULL) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  serverid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.RequestMessageIDMessage.serverID)
}

// required bytes requestID = 3;
inline bool RequestMessageIDMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestMessageIDMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestMessageIDMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestMessageIDMessage::clear_requestid() {
  requestid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_requestid();
}
inline const ::std::string& RequestMessageIDMessage::requestid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.RequestMessageIDMessage.requestID)
  return requestid_.GetNoArena();
}
inline void RequestMessageIDMessage::set_requestid(const ::std::string& value) {
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.RequestMessageIDMessage.requestID)
}
#if LANG_CXX11
inline void RequestMessageIDMessage::set_requestid(::std::string&& value) {
  set_has_requestid();
  requestid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.RequestMessageIDMessage.requestID)
}
#endif
inline void RequestMessageIDMessage::set_requestid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.RequestMessageIDMessage.requestID)
}
inline void RequestMessageIDMessage::set_requestid(const void* value, size_t size) {
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.RequestMessageIDMessage.requestID)
}
inline ::std::string* RequestMessageIDMessage::mutable_requestid() {
  set_has_requestid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.RequestMessageIDMessage.requestID)
  return requestid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestMessageIDMessage::release_requestid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.RequestMessageIDMessage.requestID)
  clear_has_requestid();
  return requestid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestMessageIDMessage::set_allocated_requestid(::std::string* requestid) {
  if (requestid != NULL) {
    set_has_requestid();
  } else {
    clear_has_requestid();
  }
  requestid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requestid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.RequestMessageIDMessage.requestID)
}

// -------------------------------------------------------------------

// ResponseMessageIDMessage

// required string userAccount = 1;
inline bool ResponseMessageIDMessage::has_useraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseMessageIDMessage::set_has_useraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseMessageIDMessage::clear_has_useraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseMessageIDMessage::clear_useraccount() {
  useraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_useraccount();
}
inline const ::std::string& ResponseMessageIDMessage::useraccount() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ResponseMessageIDMessage.userAccount)
  return useraccount_.GetNoArena();
}
inline void ResponseMessageIDMessage::set_useraccount(const ::std::string& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.ResponseMessageIDMessage.userAccount)
}
#if LANG_CXX11
inline void ResponseMessageIDMessage::set_useraccount(::std::string&& value) {
  set_has_useraccount();
  useraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.ResponseMessageIDMessage.userAccount)
}
#endif
inline void ResponseMessageIDMessage::set_useraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.ResponseMessageIDMessage.userAccount)
}
inline void ResponseMessageIDMessage::set_useraccount(const char* value, size_t size) {
  set_has_useraccount();
  useraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.ResponseMessageIDMessage.userAccount)
}
inline ::std::string* ResponseMessageIDMessage::mutable_useraccount() {
  set_has_useraccount();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.ResponseMessageIDMessage.userAccount)
  return useraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseMessageIDMessage::release_useraccount() {
  // @@protoc_insertion_point(field_release:kakaIM.president.ResponseMessageIDMessage.userAccount)
  clear_has_useraccount();
  return useraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseMessageIDMessage::set_allocated_useraccount(::std::string* useraccount) {
  if (useraccount != NULL) {
    set_has_useraccount();
  } else {
    clear_has_useraccount();
  }
  useraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), useraccount);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.ResponseMessageIDMessage.userAccount)
}

// required uint64 messageID = 2;
inline bool ResponseMessageIDMessage::has_messageid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseMessageIDMessage::set_has_messageid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseMessageIDMessage::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseMessageIDMessage::clear_messageid() {
  messageid_ = GOOGLE_ULONGLONG(0);
  clear_has_messageid();
}
inline ::google::protobuf::uint64 ResponseMessageIDMessage::messageid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ResponseMessageIDMessage.messageID)
  return messageid_;
}
inline void ResponseMessageIDMessage::set_messageid(::google::protobuf::uint64 value) {
  set_has_messageid();
  messageid_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.ResponseMessageIDMessage.messageID)
}

// required bytes requestID = 3;
inline bool ResponseMessageIDMessage::has_requestid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseMessageIDMessage::set_has_requestid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseMessageIDMessage::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseMessageIDMessage::clear_requestid() {
  requestid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_requestid();
}
inline const ::std::string& ResponseMessageIDMessage::requestid() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.ResponseMessageIDMessage.requestID)
  return requestid_.GetNoArena();
}
inline void ResponseMessageIDMessage::set_requestid(const ::std::string& value) {
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kakaIM.president.ResponseMessageIDMessage.requestID)
}
#if LANG_CXX11
inline void ResponseMessageIDMessage::set_requestid(::std::string&& value) {
  set_has_requestid();
  requestid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kakaIM.president.ResponseMessageIDMessage.requestID)
}
#endif
inline void ResponseMessageIDMessage::set_requestid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kakaIM.president.ResponseMessageIDMessage.requestID)
}
inline void ResponseMessageIDMessage::set_requestid(const void* value, size_t size) {
  set_has_requestid();
  requestid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kakaIM.president.ResponseMessageIDMessage.requestID)
}
inline ::std::string* ResponseMessageIDMessage::mutable_requestid() {
  set_has_requestid();
  // @@protoc_insertion_point(field_mutable:kakaIM.president.ResponseMessageIDMessage.requestID)
  return requestid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseMessageIDMessage::release_requestid() {
  // @@protoc_insertion_point(field_release:kakaIM.president.ResponseMessageIDMessage.requestID)
  clear_has_requestid();
  return requestid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseMessageIDMessage::set_allocated_requestid(::std::string* requestid) {
  if (requestid != NULL) {
    set_has_requestid();
  } else {
    clear_has_requestid();
  }
  requestid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), requestid);
  // @@protoc_insertion_point(field_set_allocated:kakaIM.president.ResponseMessageIDMessage.requestID)
}

// -------------------------------------------------------------------

// NodeLoadInfoMessage

// required uint64 connectionCount = 1;
inline bool NodeLoadInfoMessage::has_connectioncount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeLoadInfoMessage::set_has_connectioncount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeLoadInfoMessage::clear_has_connectioncount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeLoadInfoMessage::clear_connectioncount() {
  connectioncount_ = GOOGLE_ULONGLONG(0);
  clear_has_connectioncount();
}
inline ::google::protobuf::uint64 NodeLoadInfoMessage::connectioncount() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.NodeLoadInfoMessage.connectionCount)
  return connectioncount_;
}
inline void NodeLoadInfoMessage::set_connectioncount(::google::protobuf::uint64 value) {
  set_has_connectioncount();
  connectioncount_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.NodeLoadInfoMessage.connectionCount)
}

// required float cpuUsage = 2;
inline bool NodeLoadInfoMessage::has_cpuusage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeLoadInfoMessage::set_has_cpuusage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeLoadInfoMessage::clear_has_cpuusage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeLoadInfoMessage::clear_cpuusage() {
  cpuusage_ = 0;
  clear_has_cpuusage();
}
inline float NodeLoadInfoMessage::cpuusage() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.NodeLoadInfoMessage.cpuUsage)
  return cpuusage_;
}
inline void NodeLoadInfoMessage::set_cpuusage(float value) {
  set_has_cpuusage();
  cpuusage_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.NodeLoadInfoMessage.cpuUsage)
}

// required float memUsage = 3;
inline bool NodeLoadInfoMessage::has_memusage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeLoadInfoMessage::set_has_memusage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeLoadInfoMessage::clear_has_memusage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeLoadInfoMessage::clear_memusage() {
  memusage_ = 0;
  clear_has_memusage();
}
inline float NodeLoadInfoMessage::memusage() const {
  // @@protoc_insertion_point(field_get:kakaIM.president.NodeLoadInfoMessage.memUsage)
  return memusage_;
}
inline void NodeLoadInfoMessage::set_memusage(float value) {
  set_has_memusage();
  memusage_ = value;
  // @@protoc_insertion_point(field_set:kakaIM.president.NodeLoadInfoMessage.memUsage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace president
}  // namespace kakaIM

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kakaIM::president::ResponseJoinClusterMessage_JoinResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kakaIM::president::ResponseJoinClusterMessage_JoinResult>() {
  return ::kakaIM::president::ResponseJoinClusterMessage_JoinResult_descriptor();
}
template <> struct is_proto_enum< ::kakaIM::president::UserOnlineStateMessage_OnlineState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kakaIM::president::UserOnlineStateMessage_OnlineState>() {
  return ::kakaIM::president::UserOnlineStateMessage_OnlineState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MessageCluster_2eproto__INCLUDED
